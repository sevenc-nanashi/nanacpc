[
  "# ! atcoder/convolution.hpp\n```cpp hash\n#ifndef ATCODER_CONVOLUTION_HPP\n#define ATCODER_CONVOLUTION_HPP 1\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\n#include \"atcoder/internal_bit\"\n#include \"atcoder/modint\"\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class mint,\n          int g = internal::primitive_root<mint::mod()>,\n          internal::is_static_modint_t<mint>* = nullptr>\nstruct fft_info {\n    static constexpr int rank2 = countr_zero_constexpr(mint::mod() - 1);\n    std::array<mint, rank2 + 1> root;   // root[i]^(2^i) == 1\n    std::array<mint, rank2 + 1> iroot;  // root[i] * iroot[i] == 1\n\n    std::array<mint, std::max(0, rank2 - 2 + 1)> rate2;\n    std::array<mint, std::max(0, rank2 - 2 + 1)> irate2;\n\n    std::array<mint, std::max(0, rank2 - 3 + 1)> rate3;\n    std::array<mint, std::max(0, rank2 - 3 + 1)> irate3;\n\n    fft_info() {\n        root[rank2] = mint(g).pow((mint::mod() - 1) >> rank2);\n        iroot[rank2] = root[rank2].inv();\n        for (int i = rank2 - 1; i >= 0; i--) {\n            root[i] = root[i + 1] * root[i + 1];\n            iroot[i] = iroot[i + 1] * iroot[i + 1];\n        }\n\n        {\n            mint prod = 1, iprod = 1;\n            for (int i = 0; i <= rank2 - 2; i++) {\n                rate2[i] = root[i + 2] * prod;\n                irate2[i] = iroot[i + 2] * iprod;\n                prod *= iroot[i + 2];\n                iprod *= root[i + 2];\n            }\n        }\n        {\n            mint prod = 1, iprod = 1;\n            for (int i = 0; i <= rank2 - 3; i++) {\n                rate3[i] = root[i + 3] * prod;\n                irate3[i] = iroot[i + 3] * iprod;\n                prod *= iroot[i + 3];\n                iprod *= root[i + 3];\n            }\n        }\n    }\n};\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly(std::vector<mint>& a) {\n    int n = int(a.size());\n    int h = internal::countr_zero((unsigned int)n);\n\n    static const fft_info<mint> info;\n\n    int len = 0;  // a[i, i+(n>>len), i+2*(n>>len), ..] is transformed\n    while (len < h) {\n        if (h - len == 1) {\n            int p = 1 << (h - len - 1);\n            mint rot = 1;\n            for (int s = 0; s < (1 << len); s++) {\n                int offset = s << (h - len);\n                for (int i = 0; i < p; i++) {\n                    auto l = a[i + offset];\n                    auto r = a[i + offset + p] * rot;\n                    a[i + offset] = l + r;\n                    a[i + offset + p] = l - r;\n                }\n                if (s + 1 != (1 << len))\n                    rot *= info.rate2[countr_zero(~(unsigned int)(s))];\n            }\n            len++;\n        } else {\n            // 4-base\n            int p = 1 << (h - len - 2);\n            mint rot = 1, imag = info.root[2];\n            for (int s = 0; s < (1 << len); s++) {\n                mint rot2 = rot * rot;\n                mint rot3 = rot2 * rot;\n                int offset = s << (h - len);\n                for (int i = 0; i < p; i++) {\n                    auto mod2 = 1ULL * mint::mod() * mint::mod();\n                    auto a0 = 1ULL * a[i + offset].val();\n                    auto a1 = 1ULL * a[i + offset + p].val() * rot.val();\n                    auto a2 = 1ULL * a[i + offset + 2 * p].val() * rot2.val();\n                    auto a3 = 1ULL * a[i + offset + 3 * p].val() * rot3.val();\n                    auto a1na3imag =\n                        1ULL * mint(a1 + mod2 - a3).val() * imag.val();\n                    auto na2 = mod2 - a2;\n                    a[i + offset] = a0 + a2 + a1 + a3;\n                    a[i + offset + 1 * p] = a0 + a2 + (2 * mod2 - (a1 + a3));\n                    a[i + offset + 2 * p] = a0 + na2 + a1na3imag;\n                    a[i + offset + 3 * p] = a0 + na2 + (mod2 - a1na3imag);\n                }\n                if (s + 1 != (1 << len))\n                    rot *= info.rate3[countr_zero(~(unsigned int)(s))];\n            }\n            len += 2;\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nvoid butterfly_inv(std::vector<mint>& a) {\n    int n = int(a.size());\n    int h = internal::countr_zero((unsigned int)n);\n\n    static const fft_info<mint> info;\n\n    int len = h;  // a[i, i+(n>>len), i+2*(n>>len), ..] is transformed\n    while (len) {\n        if (len == 1) {\n            int p = 1 << (h - len);\n            mint irot = 1;\n            for (int s = 0; s < (1 << (len - 1)); s++) {\n                int offset = s << (h - len + 1);\n                for (int i = 0; i < p; i++) {\n                    auto l = a[i + offset];\n                    auto r = a[i + offset + p];\n                    a[i + offset] = l + r;\n                    a[i + offset + p] =\n                        (unsigned long long)((unsigned int)(l.val() - r.val()) + mint::mod()) *\n                        irot.val();\n                    ;\n                }\n                if (s + 1 != (1 << (len - 1)))\n                    irot *= info.irate2[countr_zero(~(unsigned int)(s))];\n            }\n            len--;\n        } else {\n            // 4-base\n            int p = 1 << (h - len);\n            mint irot = 1, iimag = info.iroot[2];\n            for (int s = 0; s < (1 << (len - 2)); s++) {\n                mint irot2 = irot * irot;\n                mint irot3 = irot2 * irot;\n                int offset = s << (h - len + 2);\n                for (int i = 0; i < p; i++) {\n                    auto a0 = 1ULL * a[i + offset + 0 * p].val();\n                    auto a1 = 1ULL * a[i + offset + 1 * p].val();\n                    auto a2 = 1ULL * a[i + offset + 2 * p].val();\n                    auto a3 = 1ULL * a[i + offset + 3 * p].val();\n\n                    auto a2na3iimag =\n                        1ULL *\n                        mint((mint::mod() + a2 - a3) * iimag.val()).val();\n\n                    a[i + offset] = a0 + a1 + a2 + a3;\n                    a[i + offset + 1 * p] =\n                        (a0 + (mint::mod() - a1) + a2na3iimag) * irot.val();\n                    a[i + offset + 2 * p] =\n                        (a0 + a1 + (mint::mod() - a2) + (mint::mod() - a3)) *\n                        irot2.val();\n                    a[i + offset + 3 * p] =\n                        (a0 + (mint::mod() - a1) + (mint::mod() - a2na3iimag)) *\n                        irot3.val();\n                }\n                if (s + 1 != (1 << (len - 2)))\n                    irot *= info.irate3[countr_zero(~(unsigned int)(s))];\n            }\n            len -= 2;\n        }\n    }\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution_naive(const std::vector<mint>& a,\n                                    const std::vector<mint>& b) {\n    int n = int(a.size()), m = int(b.size());\n    std::vector<mint> ans(n + m - 1);\n    if (n < m) {\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n    } else {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans[i + j] += a[i] * b[j];\n            }\n        }\n    }\n    return ans;\n}\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution_fft(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for (int i = 0; i < z; i++) {\n        a[i] *= b[i];\n    }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    mint iz = mint(z).inv();\n    for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\n}  // namespace internal\n\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(std::vector<mint>&& a, std::vector<mint>&& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\n    assert((mint::mod() - 1) % z == 0);\n\n    if (std::min(n, m) <= 60) return convolution_naive(std::move(a), std::move(b));\n    return internal::convolution_fft(std::move(a), std::move(b));\n}\ntemplate <class mint, internal::is_static_modint_t<mint>* = nullptr>\nstd::vector<mint> convolution(const std::vector<mint>& a,\n                              const std::vector<mint>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\n    assert((mint::mod() - 1) % z == 0);\n\n    if (std::min(n, m) <= 60) return convolution_naive(a, b);\n    return internal::convolution_fft(a, b);\n}\n\ntemplate <unsigned int mod = 998244353,\n          class T,\n          std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\nstd::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    using mint = static_modint<mod>;\n\n    int z = (int)internal::bit_ceil((unsigned int)(n + m - 1));\n    assert((mint::mod() - 1) % z == 0);\n\n    std::vector<mint> a2(n), b2(m);\n    for (int i = 0; i < n; i++) {\n        a2[i] = mint(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        b2[i] = mint(b[i]);\n    }\n    auto c2 = convolution(std::move(a2), std::move(b2));\n    std::vector<T> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        c[i] = c2[i].val();\n    }\n    return c;\n}\n\nstd::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                      const std::vector<long long>& b) {\n    int n = int(a.size()), m = int(b.size());\n    if (!n || !m) return {};\n\n    static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n    static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n    static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n    static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n    static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n    static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n\n    static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n    static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n    static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n    static constexpr int MAX_AB_BIT = 24;\n    static_assert(MOD1 % (1ull << MAX_AB_BIT) == 1, \"MOD1 isn't enough to support an array length of 2^24.\");\n    static_assert(MOD2 % (1ull << MAX_AB_BIT) == 1, \"MOD2 isn't enough to support an array length of 2^24.\");\n    static_assert(MOD3 % (1ull << MAX_AB_BIT) == 1, \"MOD3 isn't enough to support an array length of 2^24.\");\n    assert(n + m - 1 <= (1 << MAX_AB_BIT));\n\n    auto c1 = convolution<MOD1>(a, b);\n    auto c2 = convolution<MOD2>(a, b);\n    auto c3 = convolution<MOD3>(a, b);\n\n    std::vector<long long> c(n + m - 1);\n    for (int i = 0; i < n + m - 1; i++) {\n        unsigned long long x = 0;\n        x += (c1[i] * i1) % MOD1 * M2M3;\n        x += (c2[i] * i2) % MOD2 * M1M3;\n        x += (c3[i] * i3) % MOD3 * M1M2;\n        // B = 2^63, -B <= x, r(real value) < B\n        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)\n        // r = c1[i] (mod MOD1)\n        // focus on MOD1\n        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)\n        // r = x,\n        //     x - M' + (0 or 2B),\n        //     x - 2M' + (0, 2B or 4B),\n        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)\n        // (r - x) = 0, (0)\n        //           - M' + (0 or 2B), (1)\n        //           -2M' + (0 or 2B or 4B), (2)\n        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)\n        // we checked that\n        //   ((1) mod MOD1) mod 5 = 2\n        //   ((2) mod MOD1) mod 5 = 3\n        //   ((3) mod MOD1) mod 5 = 4\n        long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n        if (diff < 0) diff += MOD1;\n        static constexpr unsigned long long offset[5] = {\n            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n        x -= offset[diff % 5];\n        c[i] = x;\n    }\n\n    return c;\n}\n\n}  // namespace atcoder\n\n#endif  // ATCODER_CONVOLUTION_HPP\n\n```\n\n# ! Documentation\n# Convolution\n\nç•³ã¿è¾¼ã¿ã‚’è¡Œã„ã¾ã™ã€‚æ•°åˆ— $a_0, a_1, \\cdots, a_{N - 1}$ ã¨æ•°åˆ— $b_0, b_1, \\cdots, b_{M - 1}$ ã‹ã‚‰ã€é•·ã• $N + M - 1$ ã®æ•°åˆ—\n\n$$c_i = \\sum_{j = 0}^i a_j b_{i - j}$$\n\nã‚’è¨ˆç®—ã—ã¾ã™ã€‚\n\n## convolution\n\n```cpp\n(1) vector<T> convolution<int m = 998244353>(vector<T> a, vector<T> b)\nğŸ’»(2) vector<static_modint<m>> convolution<int m>(vector<static_modint<m>> a, vector<static_modint<m>> b)\n```\n\nç•³ã¿è¾¼ã¿ã‚’ $\\bmod m$ ã§è¨ˆç®—ã—ã¾ã™ã€‚$a, b$ ã®å°‘ãªãã¨ã‚‚ä¸€æ–¹ãŒç©ºé…åˆ—ã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $2 \\leq m \\leq 2 \\times 10^9$\n- $\\mathrm{m}$ ã¯ç´ æ•°\n- $2^c | (\\mathrm{m} - 1)$ ã‹ã¤ $|a| + |b| - 1 \\leq 2^c$ ãªã‚‹ $c$ ãŒå­˜åœ¨ã™ã‚‹\n- (1) `T`ã¯`int, uint, ll, ull`\n\n**è¨ˆç®—é‡**\n\n$n = |a| + |b|$ ã¨ã—ã¦\n\n- $O(n\\log{n} + \\log{\\mathrm{mod}})$\n\n## convolution_ll\n\n```cpp\nvector<ll> convolution_ll(vector<ll> a, vector<ll> b)\n```\n\nç•³ã¿è¾¼ã¿ã‚’è¨ˆç®—ã—ã¾ã™ã€‚$a, b$ ã®å°‘ãªãã¨ã‚‚ä¸€æ–¹ãŒç©ºé…åˆ—ã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $|a| + |b| - 1 \\leq 2^{24}$\n- ç•³ã¿è¾¼ã‚“ã å¾Œã®é…åˆ—ã®è¦ç´ ãŒå…¨ã¦`ll`ã«åã¾ã‚‹\n\n**è¨ˆç®—é‡**\n\n$n = |a| + |b|$ ã¨ã—ã¦\n\n- $O(n\\log{n})$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/convolution>\n#include <atcoder/modint>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    vector<long long> a(n), b(m);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &(a[i]));\n    }\n    for (int i = 0; i < m; i++) {\n        scanf(\"%lld\", &(b[i]));\n    }\n\n    vector<long long> c = convolution(a, b);\n    // or: vector<long long> c = convolution<998244353>(a, b);\n\n    for (int i = 0; i < n + m - 1; i++) {\n        printf(\"%lld \", c[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n```\n\n\n```cpp\n#include <atcoder/convolution>\n#include <atcoder/modint>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = modint998244353;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    vector<mint> a(n), b(m);\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        a[i] = x;\n    }\n    for (int i = 0; i < m; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        b[i] = x;\n    }\n\n    auto c = convolution(a, b);\n\n    for (int i = 0; i < n + m - 1; i++) {\n        printf(\"%d \", c[i].val());\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/dsu.hpp\n```cpp hash\n#ifndef ATCODER_DSU_HPP\n#define ATCODER_DSU_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n\n// Implement (union by size) + (path compression)\n// Reference:\n// Zvi Galil and Giuseppe F. Italiano,\n// Data structures and algorithms for disjoint set union problems\nstruct dsu {\n  public:\n    dsu() : _n(0) {}\n    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}\n\n    int merge(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        int x = leader(a), y = leader(b);\n        if (x == y) return x;\n        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n        parent_or_size[x] += parent_or_size[y];\n        parent_or_size[y] = x;\n        return x;\n    }\n\n    bool same(int a, int b) {\n        assert(0 <= a && a < _n);\n        assert(0 <= b && b < _n);\n        return leader(a) == leader(b);\n    }\n\n    int leader(int a) {\n        assert(0 <= a && a < _n);\n        return _leader(a);\n    }\n\n    int size(int a) {\n        assert(0 <= a && a < _n);\n        return -parent_or_size[leader(a)];\n    }\n\n    std::vector<std::vector<int>> groups() {\n        std::vector<int> leader_buf(_n), group_size(_n);\n        for (int i = 0; i < _n; i++) {\n            leader_buf[i] = leader(i);\n            group_size[leader_buf[i]]++;\n        }\n        std::vector<std::vector<int>> result(_n);\n        for (int i = 0; i < _n; i++) {\n            result[i].reserve(group_size[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            result[leader_buf[i]].push_back(i);\n        }\n        result.erase(\n            std::remove_if(result.begin(), result.end(),\n                           [&](const std::vector<int>& v) { return v.empty(); }),\n            result.end());\n        return result;\n    }\n\n  private:\n    int _n;\n    // root node: -1 * component size\n    // otherwise: parent\n    std::vector<int> parent_or_size;\n\n    int _leader(int a) {\n        if (parent_or_size[a] < 0) return a;\n        return parent_or_size[a] = _leader(parent_or_size[a]);\n    }\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_DSU_HPP\n\n```\n\n# ! Documentation\n# DSU\n\nç„¡å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ã€\n\n- è¾ºã®è¿½åŠ \n- $2$ é ‚ç‚¹ãŒé€£çµã‹ã®åˆ¤å®š\n\nã‚’ãªã‚‰ã— $O(\\alpha(n))$ æ™‚é–“ã§å‡¦ç†ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚\n\nã¾ãŸã€å†…éƒ¨çš„ã«å„é€£çµæˆåˆ†ã”ã¨ã«ä»£è¡¨ã¨ãªã‚‹é ‚ç‚¹ã‚’ $1$ ã¤æŒã£ã¦ã„ã¾ã™ã€‚è¾ºã®è¿½åŠ ã«ã‚ˆã‚Šé€£çµæˆåˆ†ãŒãƒãƒ¼ã‚¸ã•ã‚Œã‚‹æ™‚ã€æ–°ãŸãªä»£è¡¨å…ƒã¯å…ƒã®é€£çµæˆåˆ†ã®ä»£è¡¨å…ƒã®ã†ã¡ã©ã¡ã‚‰ã‹ã«ãªã‚Šã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\ndsu d(int n)\n```\n\n- $n$ é ‚ç‚¹ $0$ è¾ºã®ç„¡å‘ã‚°ãƒ©ãƒ•ã‚’ä½œã‚Šã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## merge\n\n```cpp\nint d.merge(int a, int b)\n```\n\nè¾º $(a, b)$ ã‚’è¶³ã—ã¾ã™ã€‚\n\n$a, b$ ãŒé€£çµã ã£ãŸå ´åˆã¯ãã®ä»£è¡¨å…ƒã€éé€£çµã ã£ãŸå ´åˆã¯æ–°ãŸãªä»£è¡¨å…ƒã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq a < n$\n- $0 \\leq b < n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(\\alpha(n))$\n\n## same\n\n```cpp\nbool d.same(int a, int b)\n```\n\né ‚ç‚¹ $a, b$ ãŒé€£çµã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq a < n$\n- $0 \\leq b < n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(\\alpha(n))$\n\n## leader\n\n```cpp\nint d.leader(int a)\n```\n\né ‚ç‚¹ $a$ ã®å±ã™ã‚‹é€£çµæˆåˆ†ã®ä»£è¡¨å…ƒã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq a < n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(\\alpha(n))$\n\n## size\n\n```cpp\nint d.size(int a)\n```\n\né ‚ç‚¹ $a$ ã®å±ã™ã‚‹é€£çµæˆåˆ†ã®ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq a < n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(\\alpha(n))$\n\n## groups\n\n```cpp\nvector<vector<int>> d.groups()\n```\n\nã‚°ãƒ©ãƒ•ã‚’é€£çµæˆåˆ†ã«åˆ†ã‘ã€ãã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚\n\nè¿”ã‚Šå€¤ã¯ã€Œã€Œä¸€ã¤ã®é€£çµæˆåˆ†ã®é ‚ç‚¹ç•ªå·ã®ãƒªã‚¹ãƒˆã€ã®ãƒªã‚¹ãƒˆã€ã§ã™ã€‚\n(å†…å´å¤–å´é™ã‚‰ãš)vectorå†…ã§ã©ã®é †ç•ªã§é ‚ç‚¹ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã‹ã¯æœªå®šç¾©ã§ã™ã€‚\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/dsu>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    dsu d(n);\n    for (int i = 0; i < q; i++) {\n        int t, u, v;\n        scanf(\"%d %d %d\", &t, &u, &v);\n        if (t == 0) {\n            d.merge(u, v);\n        } else {\n            if (d.same(u, v)) {\n                printf(\"1\\n\");\n            } else {\n                printf(\"0\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/fenwicktree.hpp\n```cpp hash\n#ifndef ATCODER_FENWICKTREE_HPP\n#define ATCODER_FENWICKTREE_HPP 1\n\n#include <cassert>\n#include <vector>\n\n#include \"atcoder/internal_type_traits\"\n\nnamespace atcoder {\n\n// Reference: https://en.wikipedia.org/wiki/Fenwick_tree\ntemplate <class T> struct fenwick_tree {\n    using U = internal::to_unsigned_t<T>;\n\n  public:\n    fenwick_tree() : _n(0) {}\n    explicit fenwick_tree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        assert(0 <= p && p < _n);\n        p++;\n        while (p <= _n) {\n            data[p - 1] += U(x);\n            p += p & -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector<U> data;\n\n    U sum(int r) {\n        U s = 0;\n        while (r > 0) {\n            s += data[r - 1];\n            r -= r & -r;\n        }\n        return s;\n    }\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_FENWICKTREE_HPP\n\n```\n\n# ! Documentation\n# Fenwick Tree\n\né•·ã• $n$ ã®é…åˆ—ã«å¯¾ã—ã€\n\n- è¦ç´ ã® $1$ ç‚¹å¤‰æ›´\n- åŒºé–“ã®è¦ç´ ã®ç·å’Œ\n\nã‚’ $O(\\log n)$ ã§æ±‚ã‚ã‚‹ã“ã¨ãŒå‡ºæ¥ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\nfenwick_tree<T> fw(int n)\n```\n\n- é•·ã• $n$ ã®é…åˆ— $a_0, a_1, \\cdots, a_{n-1}$ ã‚’ä½œã‚Šã¾ã™ã€‚åˆæœŸå€¤ã¯ã™ã¹ã¦ $0$ ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $T$ ã¯ `int / uint / ll / ull / modint`\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## add\n\n```cpp\nvoid fw.add(int p, T x)\n```\n\n`a[p] += x` ã‚’è¡Œã„ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq p < n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## sum\n\n```cpp\nT fw.sum(int l, int r)\n```\n\n`a[l] + a[l + 1] + ... + a[r - 1]` ã‚’è¿”ã—ã¾ã™ã€‚\n`T` ãŒæ•´æ•°å‹(`int / uint / ll / ull`)ã®å ´åˆã€ç­”ãˆãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãŸãªã‚‰ã° $\\bmod 2^{\\mathrm{bit}}$ ã§ç­‰ã—ã„å€¤ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq l \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/fenwicktree>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    fenwick_tree<long long> fw(n);\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        fw.add(i, a);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int t;\n        scanf(\"%d\", &t);\n        if (t == 0) {\n            int p, x;\n            scanf(\"%d %d\", &p, &x);\n            fw.add(p, x);\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%lld\\n\", fw.sum(l, r));\n        }\n    }\n}\n\n```\n\n\n",
  "# ! atcoder/internal_bit.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n#define ATCODER_INTERNAL_BITOP_HPP 1\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n#if __cplusplus >= 202002L\n#include <bit>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n#if __cplusplus >= 202002L\n\nusing std::bit_ceil;\n\n#else\n\n// @return same with std::bit::bit_ceil\nunsigned int bit_ceil(unsigned int n) {\n    unsigned int x = 1;\n    while (x < (unsigned int)(n)) x *= 2;\n    return x;\n}\n\n#endif\n\n// @param n `1 <= n`\n// @return same with std::bit::countr_zero\nint countr_zero(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\n\n// @param n `1 <= n`\n// @return same with std::bit::countr_zero\nconstexpr int countr_zero_constexpr(unsigned int n) {\n    int x = 0;\n    while (!(n & (1 << x))) x++;\n    return x;\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/internal_csr.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_CSR_HPP\n#define ATCODER_INTERNAL_CSR_HPP 1\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\nnamespace internal {\n\ntemplate <class E> struct csr {\n    std::vector<int> start;\n    std::vector<E> elist;\n    explicit csr(int n, const std::vector<std::pair<int, E>>& edges)\n        : start(n + 1), elist(edges.size()) {\n        for (auto e : edges) {\n            start[e.first + 1]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            start[i] += start[i - 1];\n        }\n        auto counter = start;\n        for (auto e : edges) {\n            elist[counter[e.first]++] = e.second;\n        }\n    }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_CSR_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/internal_math.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_MATH_HPP\n#define ATCODER_INTERNAL_MATH_HPP 1\n\n#include <utility>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n\nnamespace internal {\n\n// @param m `1 <= m`\n// @return x mod m\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if (x < 0) x += m;\n    return x;\n}\n\n// Fast modular multiplication by barrett reduction\n// Reference: https://en.wikipedia.org/wiki/Barrett_reduction\n// NOTE: reconsider after Ice Lake\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n\n    // @param m `1 <= m`\n    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n\n    // @return m\n    unsigned int umod() const { return _m; }\n\n    // @param a `0 <= a < m`\n    // @param b `0 <= b < m`\n    // @return `a * b % m`\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        // [1] m = 1\n        // a = b = im = 0, so okay\n\n        // [2] m >= 2\n        // im = ceil(2^64 / m)\n        // -> im * m = 2^64 + r (0 <= r < m)\n        // let z = a*b = c*m + d (0 <= c, d < m)\n        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im\n        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2\n        // ((ab * im) >> 64) == c or c + 1\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x =\n            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned long long y = x * _m;\n        return (unsigned int)(z - y + (z < y ? _m : 0));\n    }\n};\n\n// @param n `0 <= n`\n// @param m `1 <= m`\n// @return `(x ** n) % m`\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if (m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while (n) {\n        if (n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\n\n// Reference:\n// M. Forisek and J. Jancina,\n// Fast Primality Testing for Integers That Fit into a Machine Word\n// @param n `0 <= n`\nconstexpr bool is_prime_constexpr(int n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 7 || n == 61) return true;\n    if (n % 2 == 0) return false;\n    long long d = n - 1;\n    while (d % 2 == 0) d /= 2;\n    constexpr long long bases[3] = {2, 7, 61};\n    for (long long a : bases) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while (t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if (y != n - 1 && t % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\n// @param b `1 <= b`\n// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if (a == 0) return {b, 0};\n\n    // Contracts:\n    // [1] s - m0 * a = 0 (mod b)\n    // [2] t - m1 * a = 0 (mod b)\n    // [3] s * |m1| + t * |m0| <= b\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while (t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n\n        // [3]:\n        // (s - t * u) * |m1| + t * |m0 - m1 * u|\n        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)\n        // = s * |m1| + t * |m0| <= b\n\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    // by [3]: |m0| <= b/g\n    // by g != b: |m0| < b/g\n    if (m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if (m == 2) return 1;\n    if (m == 167772161) return 3;\n    if (m == 469762049) return 3;\n    if (m == 754974721) return 11;\n    if (m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while (x % 2 == 0) x /= 2;\n    for (int i = 3; (long long)(i)*i <= x; i += 2) {\n        if (x % i == 0) {\n            divs[cnt++] = i;\n            while (x % i == 0) {\n                x /= i;\n            }\n        }\n    }\n    if (x > 1) {\n        divs[cnt++] = x;\n    }\n    for (int g = 2;; g++) {\n        bool ok = true;\n        for (int i = 0; i < cnt; i++) {\n            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\n// @param n `n < 2^32`\n// @param m `1 <= m < 2^32`\n// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)\nunsigned long long floor_sum_unsigned(unsigned long long n,\n                                      unsigned long long m,\n                                      unsigned long long a,\n                                      unsigned long long b) {\n    unsigned long long ans = 0;\n    while (true) {\n        if (a >= m) {\n            ans += n * (n - 1) / 2 * (a / m);\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n\n        unsigned long long y_max = a * n + b;\n        if (y_max < m) break;\n        // y_max < m * (n + 1)\n        // floor(y_max / m) <= n\n        n = (unsigned long long)(y_max / m);\n        b = (unsigned long long)(y_max % m);\n        std::swap(m, a);\n    }\n    return ans;\n}\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_MATH_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/internal_queue.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_QUEUE_HPP\n#define ATCODER_INTERNAL_QUEUE_HPP 1\n\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_QUEUE_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/internal_scc.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_SCC_HPP\n#define ATCODER_INTERNAL_SCC_HPP 1\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\n#include \"atcoder/internal_csr\"\n\nnamespace atcoder {\nnamespace internal {\n\n// Reference:\n// R. Tarjan,\n// Depth-First Search and Linear Graph Algorithms\nstruct scc_graph {\n  public:\n    explicit scc_graph(int n) : _n(n) {}\n\n    int num_vertices() { return _n; }\n\n    void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n\n    // @return pair of (# of scc, scc id)\n    std::pair<int, std::vector<int>> scc_ids() {\n        auto g = csr<edge>(_n, edges);\n        int now_ord = 0, group_num = 0;\n        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n        visited.reserve(_n);\n        auto dfs = [&](auto self, int v) -> void {\n            low[v] = ord[v] = now_ord++;\n            visited.push_back(v);\n            for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                auto to = g.elist[i].to;\n                if (ord[to] == -1) {\n                    self(self, to);\n                    low[v] = std::min(low[v], low[to]);\n                } else {\n                    low[v] = std::min(low[v], ord[to]);\n                }\n            }\n            if (low[v] == ord[v]) {\n                while (true) {\n                    int u = visited.back();\n                    visited.pop_back();\n                    ord[u] = _n;\n                    ids[u] = group_num;\n                    if (u == v) break;\n                }\n                group_num++;\n            }\n        };\n        for (int i = 0; i < _n; i++) {\n            if (ord[i] == -1) dfs(dfs, i);\n        }\n        for (auto& x : ids) {\n            x = group_num - 1 - x;\n        }\n        return {group_num, ids};\n    }\n\n    std::vector<std::vector<int>> scc() {\n        auto ids = scc_ids();\n        int group_num = ids.first;\n        std::vector<int> counts(group_num);\n        for (auto x : ids.second) counts[x]++;\n        std::vector<std::vector<int>> groups(ids.first);\n        for (int i = 0; i < group_num; i++) {\n            groups[i].reserve(counts[i]);\n        }\n        for (int i = 0; i < _n; i++) {\n            groups[ids.second[i]].push_back(i);\n        }\n        return groups;\n    }\n\n  private:\n    int _n;\n    struct edge {\n        int to;\n    };\n    std::vector<std::pair<int, edge>> edges;\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_SCC_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/internal_type_traits.hpp\n```cpp hash\n#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP\n#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n\nnamespace internal {\n\n#ifndef _MSC_VER\ntemplate <class T>\nusing is_signed_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\n                                  std::is_same<T, __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\n                                  std::is_same<T, unsigned __int128>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing make_unsigned_int128 =\n    typename std::conditional<std::is_same<T, __int128_t>::value,\n                              __uint128_t,\n                              unsigned __int128>;\n\ntemplate <class T>\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\n                                                  is_signed_int128<T>::value ||\n                                                  is_unsigned_int128<T>::value,\n                                              std::true_type,\n                                              std::false_type>::type;\n\ntemplate <class T>\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                 std::is_signed<T>::value) ||\n                                                    is_signed_int128<T>::value,\n                                                std::true_type,\n                                                std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<(is_integral<T>::value &&\n                               std::is_unsigned<T>::value) ||\n                                  is_unsigned_int128<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<\n    is_signed_int128<T>::value,\n    make_unsigned_int128<T>,\n    typename std::conditional<std::is_signed<T>::value,\n                              std::make_unsigned<T>,\n                              std::common_type<T>>::type>::type;\n\n#else\n\ntemplate <class T> using is_integral = typename std::is_integral<T>;\n\ntemplate <class T>\nusing is_signed_int =\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing is_unsigned_int =\n    typename std::conditional<is_integral<T>::value &&\n                                  std::is_unsigned<T>::value,\n                              std::true_type,\n                              std::false_type>::type;\n\ntemplate <class T>\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\n                                              std::make_unsigned<T>,\n                                              std::common_type<T>>::type;\n\n#endif\n\ntemplate <class T>\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n\ntemplate <class T>\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_TYPE_TRAITS_HPP\n\n```\n\n# ! Documentation\nNo documentation found.\n",
  "# ! atcoder/lazysegtree.hpp\n```cpp hash\n#ifndef ATCODER_LAZYSEGTREE_HPP\n#define ATCODER_LAZYSEGTREE_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <functional>\n#include <vector>\n\n#include \"atcoder/internal_bit\"\n\nnamespace atcoder {\n\n#if __cplusplus >= 201703L\n\ntemplate <class S,\n          auto op,\n          auto e,\n          class F,\n          auto mapping,\n          auto composition,\n          auto id>\nstruct lazy_segtree {\n    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\n                  \"op must work as S(S, S)\");\n    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\n                  \"e must work as S()\");\n    static_assert(\n        std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,\n        \"mapping must work as S(F, S)\");\n    static_assert(\n        std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,\n        \"composition must work as F(F, F)\");\n    static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,\n                  \"id must work as F()\");\n\n#else\n\ntemplate <class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()>\nstruct lazy_segtree {\n\n#endif\n\n  public:\n    lazy_segtree() : lazy_segtree(0) {}\n    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        size = (int)internal::bit_ceil((unsigned int)(_n));\n        log = internal::countr_zero((unsigned int)size);\n        d = std::vector<S>(2 * size, e());\n        lz = std::vector<F>(size, id());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        S sml = e(), smr = e();\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 <= p && p < _n);\n        p += size;\n        for (int i = log; i >= 1; i--) push(p >> i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 <= l && l <= r && r <= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i >= 1; i--) {\n            if (((l >> i) << i) != l) push(l >> i);\n            if (((r >> i) << i) != r) push((r - 1) >> i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l < r) {\n                if (l & 1) all_apply(l++, f);\n                if (r & 1) all_apply(--r, f);\n                l >>= 1;\n                r >>= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i <= log; i++) {\n            if (((l >> i) << i) != l) update(l >> i);\n            if (((r >> i) << i) != r) update((r - 1) >> i);\n        }\n    }\n\n    template <bool (*g)(S)> int max_right(int l) {\n        return max_right(l, [](S x) { return g(x); });\n    }\n    template <class G> int max_right(int l, G g) {\n        assert(0 <= l && l <= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i >= 1; i--) push(l >> i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l < size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*g)(S)> int min_left(int r) {\n        return min_left(r, [](S x) { return g(x); });\n    }\n    template <class G> int min_left(int r, G g) {\n        assert(0 <= r && r <= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i >= 1; i--) push((r - 1) >> i);\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!g(op(d[r], sm))) {\n                while (r < size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n    std::vector<F> lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k < size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_LAZYSEGTREE_HPP\n\n```\n\n# ! Documentation\n# Lazy Segtree\n\n[ãƒ¢ãƒã‚¤ãƒ‰](https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89) $(S, \\cdot: S \\times S \\to S, e \\in S)$ã¨ã€$S$ ã‹ã‚‰ $S$ ã¸ã®å†™åƒã®é›†åˆ $F$ ã§ã‚ã£ã¦ã€ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªã‚‚ã®ã«ã¤ã„ã¦ä½¿ç”¨ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚\n\n- $F$ ã¯æ’ç­‰å†™åƒ $\\mathrm{id}$ ã‚’å«ã‚€ã€‚ã¤ã¾ã‚Šã€ä»»æ„ã® $x \\in S$ ã«å¯¾ã— $\\mathrm{id}(x) = x$ ã‚’ã¿ãŸã™ã€‚\n- $F$ ã¯å†™åƒã®åˆæˆã«ã¤ã„ã¦é–‰ã˜ã¦ã„ã‚‹ã€‚ã¤ã¾ã‚Šã€ä»»æ„ã® $f, g \\in F$ ã«å¯¾ã— $f \\circ g \\in F$ ã§ã‚ã‚‹ã€‚\n- ä»»æ„ã® $f \\in F, x, y \\in S$ ã«å¯¾ã— $f(x \\cdot y) = f(x) \\cdot f(y)$ ã‚’ã¿ãŸã™ã€‚\n\né•·ã• $N$ ã® $S$ ã®é…åˆ—ã«å¯¾ã—ã€\n\n- åŒºé–“ã®è¦ç´ ã«ä¸€æ‹¬ã§ $F$ ã®è¦ç´  $f$ ã‚’ä½œç”¨($x = f(x)$ )\n- åŒºé–“ã®è¦ç´ ã®ç·ç©ã®å–å¾—\n\nã‚’ $O(\\log N)$ ã§è¡Œã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚è©³ç´°ãªè¦ä»¶ã¯ [Appendix](./appendix.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\nã¾ãŸã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ªãƒ©ã‚¯ãƒ«ã¨ã—ã¦`op, e, mapping, composition, id`ã‚’ä½¿ç”¨ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ãŒå®šæ•°æ™‚é–“ã§å‹•ãã‚‚ã®ã¨ä»®å®šã—ãŸã¨ãã®è¨ˆç®—é‡ã‚’è¨˜è¿°ã—ã¾ã™ã€‚ã‚ªãƒ©ã‚¯ãƒ«å†…éƒ¨ã®è¨ˆç®—é‡ãŒ $O(f(n))$ ã§ã‚ã‚‹å ´åˆã¯ã™ã¹ã¦ã®è¨ˆç®—é‡ãŒ $O(f(n))$ å€ã¨ãªã‚Šã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\n(1) lazy_segtree<S, op, e, F, mapping, composition, id> seg(int n);\n(2) lazy_segtree<S, op, e, F, mapping, composition, id> seg(vector<S> v);\n```\n\n- ãƒ¢ãƒã‚¤ãƒ‰ã®å‹ `S`\n- $\\cdot: S \\times S \\to S$ ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•° `S op(S a, S b)`\n- $e$ ã‚’è¿”ã™é–¢æ•° `S e()`\n- å†™åƒã®å‹ `F`\n- $f(x)$ ã‚’è¿”ã™é–¢æ•° `S mapping(F f, S x)`\n- $f \\circ g$ ã‚’è¿”ã™é–¢æ•° `F composition(F f, F g)`\n- $id$ ã‚’è¿”ã™é–¢æ•° `F id()`\n\nã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\nè©³ã—ãã¯ã€ä½¿ç”¨ä¾‹ã‚„ [ã“ã¡ã‚‰](https://atcoder.jp/contests/practice2/editorial) ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\n- (1): é•·ã• `n` ã®æ•°åˆ— `a` ã‚’ä½œã‚Šã¾ã™ã€‚åˆæœŸå€¤ã¯å…¨éƒ¨`e()`ã§ã™ã€‚\n- (2): é•·ã• `n = v.size()` ã®æ•°åˆ— `a` ã‚’ä½œã‚Šã¾ã™ã€‚`v` ã®å†…å®¹ãŒåˆæœŸå€¤ã¨ãªã‚Šã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## set\n\n```cpp\nvoid seg.set(int p, S x)\n```\n\n`a[p] = x`\n\n**åˆ¶ç´„**\n\n- $0 \\leq p < n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## get\n\n```cpp\nS seg.get(int p)\n```\n\n`a[p]` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq p < n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## prod\n\n```cpp\nS seg.prod(int l, int r)\n```\n\n`op(a[l], ..., a[r - 1])` ã‚’ã€ãƒ¢ãƒã‚¤ãƒ‰ã®æ€§è³ªã‚’æº€ãŸã—ã¦ã„ã‚‹ã¨ä»®å®šã—ã¦è¨ˆç®—ã—ã¾ã™ã€‚$l = r$ ã®ã¨ãã¯ `e()` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq l \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## all_prod\n\n```cpp\nS seg.all_prod()\n```\n\n`op(a[0], ..., a[n-1])` ã‚’è¨ˆç®—ã—ã¾ã™ã€‚$n = 0$ ã®ã¨ãã¯ `e()` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**è¨ˆç®—é‡**\n\n- $O(1)$\n\n## apply\n\n```cpp\n(1) void seg.apply(int p, F f)\n(2) void seg.apply(int l, int r, F f)\n```\n\n- (1) `a[p] = f(a[p])`\n- (2) `i = l..r-1`ã«ã¤ã„ã¦`a[i] = f(a[i])`\n\n**åˆ¶ç´„**\n\n- (1) $0 \\leq p < n$\n- (2) $0 \\leq l \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## max_right\n\n```cpp\n(1) int seg.max_right<g>(int l)\n(2ğŸ’») int seg.max_right<G>(int l, G g)\n```\n\n- (1): é–¢æ•° `bool g(S x)` ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  \n- (2): `S`ã‚’å¼•æ•°ã«ã¨ã‚Š`bool`ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  \n\nä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ `r` ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚\n\n- `r = l` ã‚‚ã—ãã¯ `g(op(a[l], a[l + 1], ..., a[r - 1])) = true`\n- `r = n` ã‚‚ã—ãã¯ `g(op(a[l], a[l + 1], ..., a[r])) = false`\n\n`g`ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€`g(op(a[l], a[l + 1], ..., a[r - 1])) = true` ã¨ãªã‚‹æœ€å¤§ã® `r`ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `g`ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)\n- `g(e()) = true`\n- $0 \\leq l \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## min_left\n\n```cpp\n(1) int seg.min_left<g>(int r)\n(2ğŸ’») int seg.min_left<G>(int r, G g)\n```\n\n- (1): é–¢æ•° `bool g(S x)` ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  \n- (2): `S`ã‚’å¼•æ•°ã«ã¨ã‚Š`bool`ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  \n\nä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ `l` ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚\n\n- `l = r` ã‚‚ã—ãã¯ `g(op(a[l], a[l + 1], ..., a[r - 1])) = true`\n- `l = 0` ã‚‚ã—ãã¯ `g(op(a[l - 1], a[l], ..., a[r - 1])) = false`\n\n`g`ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€`g(op(a[l], a[l + 1], ..., a[r - 1])) = true` ã¨ãªã‚‹æœ€å°ã® `l`ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `g`ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)\n- `g(e()) = true`\n- $0 \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/lazysegtree>\n#include <atcoder/modint>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = modint998244353;\n\nstruct S {\n    mint a;\n    int size;\n};\n\nstruct F {\n    mint a, b;\n};\n\nS op(S l, S r) { return S{l.a + r.a, l.size + r.size}; }\n\nS e() { return S{0, 0}; }\n\nS mapping(F l, S r) { return S{r.a * l.a + r.size * l.b, r.size}; }\n\nF composition(F l, F r) { return F{r.a * l.a, r.b * l.a + l.b}; }\n\nF id() { return F{1, 0}; }\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    vector<S> a(n);\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        a[i] = S{x, 1};\n    }\n\n    lazy_segtree<S, op, e, F, mapping, composition, id> seg(a);\n\n    for (int i = 0; i < q; i++) {\n        int t;\n        scanf(\"%d\", &t);\n        if (t == 0) {\n            int l, r;\n            int c, d;\n            scanf(\"%d %d %d %d\", &l, &r, &c, &d);\n            seg.apply(l, r, F{c, d});\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%d\\n\", seg.prod(l, r).a.val());\n        }\n    }\n}\n\n```\n\n\n```cpp\n#include <atcoder/lazysegtree>\n#include <atcoder/modint>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = modint998244353;\n\nstruct S {\n    // # of 0 / # of 1 / inversion number\n    long long zero, one, inversion;\n};\n\n// swapping flag\nusing F = bool;\n\nS op(S l, S r) {\n    return S{\n        l.zero + r.zero,\n        l.one + r.one,\n        l.inversion + r.inversion + l.one * r.zero,\n    };\n}\n\nS e() { return S{0, 0, 0}; }\n\nS mapping(F l, S r) {\n    if (!l) return r;\n    // swap\n    return S{r.one, r.zero, r.one * r.zero - r.inversion};\n}\n\nF composition(F l, F r) { return (l && !r) || (!l && r); }\n\nF id() { return false; }\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    vector<S> a(n);\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        if (x == 0)\n            a[i] = S{1, 0, 0};\n        else\n            a[i] = S{0, 1, 0};\n    }\n\n    lazy_segtree<S, op, e, F, mapping, composition, id> seg(a);\n    for (int i = 0; i < q; i++) {\n        int t, l, r;\n        scanf(\"%d %d %d\", &t, &l, &r);\n        l--;\n        if (t == 1) {\n            seg.apply(l, r, true);\n        } else {\n            printf(\"%lld\\n\", seg.prod(l, r).inversion);\n        }\n    }\n}\n\n```\n\n\n",
  "# ! atcoder/math.hpp\n```cpp hash\n#ifndef ATCODER_MATH_HPP\n#define ATCODER_MATH_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\n#include \"atcoder/internal_math\"\n\nnamespace atcoder {\n\nlong long pow_mod(long long x, long long n, int m) {\n    assert(0 <= n && 1 <= m);\n    if (m == 1) return 0;\n    internal::barrett bt((unsigned int)(m));\n    unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n    while (n) {\n        if (n & 1) r = bt.mul(r, y);\n        y = bt.mul(y, y);\n        n >>= 1;\n    }\n    return r;\n}\n\nlong long inv_mod(long long x, long long m) {\n    assert(1 <= m);\n    auto z = internal::inv_gcd(x, m);\n    assert(z.first == 1);\n    return z.second;\n}\n\n// (rem, mod)\nstd::pair<long long, long long> crt(const std::vector<long long>& r,\n                                    const std::vector<long long>& m) {\n    assert(r.size() == m.size());\n    int n = int(r.size());\n    // Contracts: 0 <= r0 < m0\n    long long r0 = 0, m0 = 1;\n    for (int i = 0; i < n; i++) {\n        assert(1 <= m[i]);\n        long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n        if (m0 < m1) {\n            std::swap(r0, r1);\n            std::swap(m0, m1);\n        }\n        if (m0 % m1 == 0) {\n            if (r0 % m1 != r1) return {0, 0};\n            continue;\n        }\n        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)\n\n        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));\n        // r2 % m0 = r0\n        // r2 % m1 = r1\n        // -> (r0 + x*m0) % m1 = r1\n        // -> x*u0*g = r1-r0 (mod u1*g) (u0*g = m0, u1*g = m1)\n        // -> x = (r1 - r0) / g * inv(u0) (mod u1)\n\n        // im = inv(u0) (mod u1) (0 <= im < u1)\n        long long g, im;\n        std::tie(g, im) = internal::inv_gcd(m0, m1);\n\n        long long u1 = (m1 / g);\n        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)\n        if ((r1 - r0) % g) return {0, 0};\n\n        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)\n        long long x = (r1 - r0) / g % u1 * im % u1;\n\n        // |r0| + |m0 * x|\n        // < m0 + m0 * (u1 - 1)\n        // = m0 + m0 * m1 / g - m0\n        // = lcm(m0, m1)\n        r0 += x * m0;\n        m0 *= u1;  // -> lcm(m0, m1)\n        if (r0 < 0) r0 += m0;\n    }\n    return {r0, m0};\n}\n\nlong long floor_sum(long long n, long long m, long long a, long long b) {\n    assert(0 <= n && n < (1LL << 32));\n    assert(1 <= m && m < (1LL << 32));\n    unsigned long long ans = 0;\n    if (a < 0) {\n        unsigned long long a2 = internal::safe_mod(a, m);\n        ans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m);\n        a = a2;\n    }\n    if (b < 0) {\n        unsigned long long b2 = internal::safe_mod(b, m);\n        ans -= 1ULL * n * ((b2 - b) / m);\n        b = b2;\n    }\n    return ans + internal::floor_sum_unsigned(n, m, a, b);\n}\n\n}  // namespace atcoder\n\n#endif  // ATCODER_MATH_HPP\n\n```\n\n# ! Documentation\n# Math\n\næ•°è«–çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è©°ã‚åˆã‚ã›ã§ã™ã€‚\n\n## pow_mod\n\n```cpp\nll pow_mod(ll x, ll n, int m)\n```\n\n$x^n \\bmod m$ ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\le n$\n- $1 \\le m$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## inv_mod\n\n```cpp\nll inv_mod(ll x, ll m)\n```\n\n$xy \\equiv 1 \\pmod m$ ãªã‚‹ $y$ ã®ã†ã¡ã€$0 \\le y < m$ ã‚’æº€ãŸã™ã‚‚ã®ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $\\gcd(x, m) = 1$\n- $1 \\leq m$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log m)$\n\n## crt\n\n```cpp\npair<ll, ll> crt(vector<ll> r, vector<ll> m)\n```\n\nåŒã˜é•·ã•ã®é…åˆ— $r, m$ ã‚’æ¸¡ã—ã¾ã™ã€‚ã“ã®é…åˆ—ã®é•·ã•ã‚’ $n$ ã¨ã—ãŸæ™‚ã€\n\n$$x \\equiv r[i] \\pmod{m[i]}, \\forall i \\in \\lbrace 0,1,\\cdots, n - 1 \\rbrace$$\n\nã‚’è§£ãã¾ã™ã€‚ç­”ãˆã¯(å­˜åœ¨ã™ã‚‹ãªã‚‰ã°) $y, z (0 \\leq y < z = \\mathrm{lcm}(m[i]))$ ã‚’ç”¨ã„ã¦ $x \\equiv y \\pmod z$ ã®å½¢ã§æ›¸ã‘ã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ãŠã‚Šã€ã“ã® $(y, z)$ ã‚’pairã¨ã—ã¦è¿”ã—ã¾ã™ã€‚ç­”ãˆãŒãªã„å ´åˆã¯ $(0, 0)$ ã‚’è¿”ã—ã¾ã™ã€‚$n=0$ ã®æ™‚ã¯ $(0, 1)$ ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $|r| = |m|$\n- $1 \\le m[i]$\n- $\\mathrm{lcm}(m[i])$ ãŒ `ll` ã«åã¾ã‚‹ã€‚\n\n**è¨ˆç®—é‡**\n\n- $O(n \\log{\\mathrm{lcm}(m[i])})$\n\n## floor_sum\n\n```cpp\nll floor_sum(ll n, ll m, ll a, ll b)\n```\n\n$$\\sum_{i = 0}^{n - 1} \\left\\lfloor \\frac{a \\times i + b}{m} \\right\\rfloor$$\n\nã‚’è¿”ã—ã¾ã™ã€‚ç­”ãˆãŒã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãŸãªã‚‰ã° $\\bmod 2^{\\mathrm{64}}$ ã§ç­‰ã—ã„å€¤ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\lt 2^{32}$\n- $1 \\leq m \\lt 2^{32}$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log m)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/math>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int i = 0; i < t; i++) {\n        long long n, m, a, b;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &a, &b);\n        printf(\"%lld\\n\", floor_sum(n, m, a, b));\n    }\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/maxflow.hpp\n```cpp hash\n#ifndef ATCODER_MAXFLOW_HPP\n#define ATCODER_MAXFLOW_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\n#include \"atcoder/internal_queue\"\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    explicit mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to, to_id, cap});\n        g[to].push_back(_edge{from, from_id, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) return res;\n            }\n            level[v] = _n;\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            Cap f = dfs(dfs, t, flow_limit - flow);\n            if (!f) break;\n            flow += f;\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_MAXFLOW_HPP\n\n```\n\n# ! Documentation\n# MaxFlow\n\n[æœ€å¤§ãƒ•ãƒ­ãƒ¼å•é¡Œ](https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E5%95%8F%E9%A1%8C) ã‚’è§£ããƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\nmf_graph<Cap> graph(int n)\n```\n\n`n` é ‚ç‚¹ $0$ è¾ºã®ã‚°ãƒ©ãƒ•ã‚’ä½œã‚‹ã€‚`Cap`ã¯å®¹é‡ã®å‹ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n- `Cap` ã¯ `int`, `ll`\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## add_edge\n\n```cpp\nint graph.add_edge(int from, int to, Cap cap);\n```\n\n`from`ã‹ã‚‰`to`ã¸æœ€å¤§å®¹é‡`cap`ã€æµé‡ $0$ ã®è¾ºã‚’è¿½åŠ ã—ã€ä½•ç•ªç›®ã«è¿½åŠ ã•ã‚ŒãŸè¾ºã‹ã‚’è¿”ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq \\mathrm{from}, \\mathrm{to} \\lt n$\n- $0 \\leq \\mathrm{cap}$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(1)$\n\n## flow\n\n```cpp\n(1) Cap graph.flow(int s, int t);\n(2) Cap graph.flow(int s, int t, Cap flow_limit);\n```\n\n- (1) é ‚ç‚¹ $s$ ã‹ã‚‰ $t$ ã¸æµã›ã‚‹é™ã‚Šæµã—ã€æµã›ãŸé‡ã‚’è¿”ã™ã€‚\n- (2) é ‚ç‚¹ $s$ ã‹ã‚‰ $t$ ã¸æµé‡ `flow_limit` ã«é”ã™ã‚‹ã¾ã§æµã›ã‚‹é™ã‚Šæµã—ã€æµã›ãŸé‡ã‚’è¿”ã™ã€‚\n- è¤‡æ•°å›å‘¼ã¶ã“ã¨ã‚‚å¯èƒ½ã§ã€ãã®æ™‚ã®æŒ™å‹•ã¯ [Appendix](./appendix.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\n**åˆ¶ç´„**\n\n- $s \\neq t$\n- $0 \\leq s, t \\lt n$\n- è¿”ã‚Šå€¤ãŒ `Cap` ã«åã¾ã‚‹\n\n**è¨ˆç®—é‡**\n\n$m$ ã‚’è¿½åŠ ã•ã‚ŒãŸè¾ºæ•°ã¨ã—ã¦\n\n- $O((n + m) \\sqrt{m})$ (è¾ºã®å®¹é‡ãŒã™ã¹ã¦ $1$ ã®æ™‚)\n- $O(n^2 m)$\n- è¿”ã‚Šå€¤ã‚’ $F$ ã¨ã—ã¦ $O(F(n + m))$\n\n## min_cut\n\n```cpp\nvector<bool> graph.min_cut(int s)\n```\n\né•·ã• $n$ ã®vectorã‚’è¿”ã™ã€‚$i$ ç•ªç›®ã®è¦ç´ ã«ã¯ã€é ‚ç‚¹ $s$ ã‹ã‚‰ $i$ ã¸æ®‹ä½™ã‚°ãƒ©ãƒ•ã§åˆ°é”å¯èƒ½ãªã¨ãã€ã¾ãŸãã®æ™‚ã®ã¿ `true` ã‚’è¿”ã™ã€‚`flow(s, t)`ã‚’flow_limitãªã—ã§ã¡ã‚‡ã†ã©ä¸€å›å‘¼ã‚“ã å¾Œã«å‘¼ã¶ã¨ã€è¿”ã‚Šå€¤ã¯ $s$, $t$ é–“ã®mincutã«å¯¾å¿œã—ã¾ã™ã€‚è©³ç´°ãªæŒ™å‹•ã¯ [Appendix](./appendix.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\n**è¨ˆç®—é‡**\n\n$m$ ã‚’è¿½åŠ ã•ã‚ŒãŸè¾ºæ•°ã¨ã—ã¦\n\n- $O(n + m)$\n\n## get_edge / edges\n\n```cpp\nstruct mf_graph<Cap>::edge {\n    int from, to;\n    Cap cap, flow;\n};\n\n(1) mf_graph<Cap>::edge graph.get_edge(int i);\n(2) vector<mf_graph<Cap>::edge> graph.edges();\n```\n\n- ä»Šã®å†…éƒ¨ã®è¾ºã®çŠ¶æ…‹ã‚’è¿”ã™\n- è¾ºã®é †ç•ªã¯add_edgeã§è¿½åŠ ã•ã‚ŒãŸé †ç•ªã¨åŒä¸€\n\n**åˆ¶ç´„**\n\n- (1): $0 \\leq i \\lt m$\n\n**è¨ˆç®—é‡**\n\n$m$ ã‚’è¿½åŠ ã•ã‚ŒãŸè¾ºæ•°ã¨ã—ã¦\n\n- (1): $O(1)$\n- (2): $O(m)$\n\n## change_edge\n\n```cpp\nvoid graph.change_edge(int i, Cap new_cap, Cap new_flow);\n```\n\n$i$ ç•ªç›®ã«è¿½åŠ ã•ã‚ŒãŸè¾ºã®å®¹é‡ã€æµé‡ã‚’`new_cap`, `new_flow`ã«å¤‰æ›´ã™ã‚‹ã€‚ä»–ã®è¾ºã®å®¹é‡ã€æµé‡ã¯å¤‰æ›´ã—ãªã„ã€‚è©³ç´°ã¯ [Appendix](./appendix.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„\n\n**åˆ¶ç´„**\n\n- $0 \\leq \\mathrm{newflow} \\leq \\mathrm{newcap}$\n\n**è¨ˆç®—é‡**\n\n- $O(1)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/maxflow>\n#include <iostream>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grid[i];\n    }\n\n    /**\n     * generate (s -> even grid -> odd grid -> t) graph\n     * grid(i, j) correspond to vertex (i * m + j)\n     **/\n    mf_graph<int> g(n * m + 2);\n    int s = n * m, t = n * m + 1;\n\n    // s -> even / odd -> t\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '#') continue;\n            int v = i * m + j;\n            if ((i + j) % 2 == 0) {\n                g.add_edge(s, v, 1);\n            } else {\n                g.add_edge(v, t, 1);\n            }\n        }\n    }\n\n    // even -> odd\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 || grid[i][j] == '#') continue;\n            int v0 = i * m + j;\n            if (i && grid[i - 1][j] == '.') {\n                int v1 = (i - 1) * m + j;\n                g.add_edge(v0, v1, 1);\n            }\n            if (j && grid[i][j - 1] == '.') {\n                int v1 = i * m + (j - 1);\n                g.add_edge(v0, v1, 1);\n            }\n            if (i + 1 < n && grid[i + 1][j] == '.') {\n                int v1 = (i + 1) * m + j;\n                g.add_edge(v0, v1, 1);\n            }\n            if (j + 1 < m && grid[i][j + 1] == '.') {\n                int v1 = i * m + (j + 1);\n                g.add_edge(v0, v1, 1);\n            }\n        }\n    }\n\n    cout << g.flow(s, t) << endl;\n\n    auto edges = g.edges();\n    for (auto e : edges) {\n        if (e.from == s || e.to == t || e.flow == 0) continue;\n        int i0 = e.from / m, j0 = e.from % m;\n        int i1 = e.to / m, j1 = e.to % m;\n\n        if (i0 == i1 + 1) {\n            grid[i1][j1] = 'v';\n            grid[i0][j0] = '^';\n        } else if (j0 == j1 + 1) {\n            grid[i1][j1] = '>'; grid[i0][j0] = '<';\n        } else if (i0 == i1 - 1) {\n            grid[i0][j0] = 'v';\n            grid[i1][j1] = '^';\n        } else {\n            grid[i0][j0] = '>'; grid[i1][j1] = '<';\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << grid[i] << endl;\n    }\n\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/mincostflow.hpp\n```cpp hash\n#ifndef ATCODER_MINCOSTFLOW_HPP\n#define ATCODER_MINCOSTFLOW_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\n#include \"atcoder/internal_csr\"\n#include \"atcoder/internal_queue\"\n\nnamespace atcoder {\n\ntemplate <class Cap, class Cost> struct mcf_graph {\n  public:\n    mcf_graph() {}\n    explicit mcf_graph(int n) : _n(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        assert(0 <= cost);\n        int m = int(_edges.size());\n        _edges.push_back({from, to, cap, 0, cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    edge get_edge(int i) {\n        int m = int(_edges.size());\n        assert(0 <= i && i < m);\n        return _edges[i];\n    }\n    std::vector<edge> edges() { return _edges; }\n\n    std::pair<Cap, Cost> flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n        return slope(s, t, std::numeric_limits<Cap>::max());\n    }\n    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n\n        int m = int(_edges.size());\n        std::vector<int> edge_idx(m);\n\n        auto g = [&]() {\n            std::vector<int> degree(_n), redge_idx(m);\n            std::vector<std::pair<int, _edge>> elist;\n            elist.reserve(2 * m);\n            for (int i = 0; i < m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] = degree[e.from]++;\n                redge_idx[i] = degree[e.to]++;\n                elist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});\n                elist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});\n            }\n            auto _g = internal::csr<_edge>(_n, elist);\n            for (int i = 0; i < m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] += _g.start[e.from];\n                redge_idx[i] += _g.start[e.to];\n                _g.elist[edge_idx[i]].rev = redge_idx[i];\n                _g.elist[redge_idx[i]].rev = edge_idx[i];\n            }\n            return _g;\n        }();\n\n        auto result = slope(g, s, t, flow_limit);\n\n        for (int i = 0; i < m; i++) {\n            auto e = g.elist[edge_idx[i]];\n            _edges[i].flow = _edges[i].cap - e.cap;\n        }\n\n        return result;\n    }\n\n  private:\n    int _n;\n    std::vector<edge> _edges;\n\n    // inside edge\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,\n                                            int s,\n                                            int t,\n                                            Cap flow_limit) {\n        // variants (C = maxcost):\n        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge\n\n        // dual_dist[i] = (dual[i], dist[i])\n        std::vector<std::pair<Cost, Cost>> dual_dist(_n);\n        std::vector<int> prev_e(_n);\n        std::vector<bool> vis(_n);\n        struct Q {\n            Cost key;\n            int to;\n            bool operator<(Q r) const { return key > r.key; }\n        };\n        std::vector<int> que_min;\n        std::vector<Q> que;\n        auto dual_ref = [&]() {\n            for (int i = 0; i < _n; i++) {\n                dual_dist[i].second = std::numeric_limits<Cost>::max();\n            }\n            std::fill(vis.begin(), vis.end(), false);\n            que_min.clear();\n            que.clear();\n\n            // que[0..heap_r) was heapified\n            size_t heap_r = 0;\n\n            dual_dist[s].second = 0;\n            que_min.push_back(s);\n            while (!que_min.empty() || !que.empty()) {\n                int v;\n                if (!que_min.empty()) {\n                    v = que_min.back();\n                    que_min.pop_back();\n                } else {\n                    while (heap_r < que.size()) {\n                        heap_r++;\n                        std::push_heap(que.begin(), que.begin() + heap_r);\n                    }\n                    v = que.front().to;\n                    std::pop_heap(que.begin(), que.end());\n                    que.pop_back();\n                    heap_r--;\n                }\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] >= 0 (all reduced cost are positive)\n                // dist[v] <= (n-1)C\n                Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;\n                for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                    auto e = g.elist[i];\n                    if (!e.cap) continue;\n                    // |-dual[e.to] + dual[v]| <= (n-1)C\n                    // cost <= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual_dist[e.to].first + dual_v;\n                    if (dual_dist[e.to].second - dist_v > cost) {\n                        Cost dist_to = dist_v + cost;\n                        dual_dist[e.to].second = dist_to;\n                        prev_e[e.to] = e.rev;\n                        if (dist_to == dist_v) {\n                            que_min.push_back(e.to);\n                        } else {\n                            que.push_back(Q{dist_to, e.to});\n                        }\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v < _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) +\n                //         (shortest(s, v) + dual[s] - dual[v]) = - shortest(s,\n                //         t) + dual[t] + shortest(s, v) = shortest(s, v) -\n                //         shortest(s, t) >= 0 - (n-1)C\n                dual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost_per_flow = -1;\n        std::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};\n        while (flow < flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\n                c = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);\n            }\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\n                auto& e = g.elist[prev_e[v]];\n                e.cap += c;\n                g.elist[e.rev].cap -= c;\n            }\n            Cost d = -dual_dist[s].first;\n            flow += c;\n            cost += c * d;\n            if (prev_cost_per_flow == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost_per_flow = d;\n        }\n        return result;\n    }\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_MINCOSTFLOW_HPP\n\n```\n\n# ! Documentation\n# MinCostFlow\n\n[Minimum-cost flow problem](https://en.wikipedia.org/wiki/Minimum-cost_flow_problem)ã‚’æ‰±ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\nmcf_graph<Cap, Cost> graph(int n);\n```\n\n$n$ é ‚ç‚¹ $0$ è¾ºã®ã‚°ãƒ©ãƒ•ã‚’ä½œã‚‹ã€‚`Cap`ã¯å®¹é‡ã®å‹ã€`Cost`ã¯ã‚³ã‚¹ãƒˆã®å‹\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n- `Cap, Cost` ã¯ `int, ll`\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## add_edge\n\n```cpp\nint graph.add_edge(int from, int to, Cap cap, Cost cost);\n```\n\n`from`ã‹ã‚‰`to`ã¸æœ€å¤§å®¹é‡`cap`, ã‚³ã‚¹ãƒˆ`cost`ã®è¾ºã‚’è¿½åŠ ã™ã‚‹ã€‚ä½•ç•ªç›®ã«è¿½åŠ ã•ã‚ŒãŸè¾ºã‹ã‚’è¿”ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq \\mathrm{from}, \\mathrm{to} \\lt n$\n- $0 \\leq \\mathrm{cap}, \\mathrm{cost}$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(1)$\n\n## min_cost_max_flow\n\n```cpp\n(1) pair<Cap, Cost> graph.flow(int s, int t);\n(2) pair<Cap, Cost> graph.flow(int s, int t, Cap flow_limit);\n```\n\n$s$ ã‹ã‚‰ $t$ ã¸æµã›ã‚‹ã ã‘æµã—ã€ãã®æµé‡ã¨ã‚³ã‚¹ãƒˆã‚’è¿”ã™ã€‚\n\n- (1) $s$ ã‹ã‚‰ $t$ ã¸æµã›ã‚‹ã ã‘æµã™\n- (2) $s$ ã‹ã‚‰ $t$ ã¸æµé‡`flow_limit`ã¾ã§æµã›ã‚‹ã ã‘æµã™\n\n**åˆ¶ç´„**\n\n- `min_cost_slope`ã¨åŒã˜\n\n**è¨ˆç®—é‡**\n\n- `min_cost_slope`ã¨åŒã˜\n\n## min_cost_slope\n\n```cpp\nvector<pair<Cap, Cost>> graph.slope(int s, int t);\nvector<pair<Cap, Cost>> graph.slope(int s, int t, Cap flow_limit);\n```\n\nè¿”ã‚Šå€¤ã«æµé‡ã¨ã‚³ã‚¹ãƒˆã®é–¢ä¿‚ã®æŠ˜ã‚Œç·šãŒå…¥ã‚‹ã€‚å…¨ã¦ã® $x$ ã«ã¤ã„ã¦ã€æµé‡ $x$ ã®æ™‚ã®æœ€å°ã‚³ã‚¹ãƒˆã‚’ $g(x)$ ã¨ã™ã‚‹ã¨ã€$(x, g(x))$ ã¯è¿”ã‚Šå€¤ã‚’æŠ˜ã‚Œç·šã¨ã—ã¦è¦‹ãŸã‚‚ã®ã«å«ã¾ã‚Œã‚‹ã€‚\n\n- è¿”ã‚Šå€¤ã®æœ€åˆã®è¦ç´ ã¯ $(0, 0)$\n- è¿”ã‚Šå€¤ã®`.first` ã¯ç‹­ç¾©å˜èª¿å¢—åŠ ã€`.second`ã¯åºƒç¾©å˜èª¿å¢—åŠ \n- 3ç‚¹ãŒåŒä¸€ç·šä¸Šã«ã‚ã‚‹ã“ã¨ã¯ãªã„\n- (1) è¿”ã‚Šå€¤ã®æœ€å¾Œã®è¦ç´ ã¯æœ€å¤§æµé‡ $x$ ã¨ã—ã¦ $(x, g(x))$\n- (2) è¿”ã‚Šå€¤ã®æœ€å¾Œã®è¦ç´ ã¯ $y = \\min(x, \\mathrm{flow\\\\_limit})$ ã¨ã—ã¦ $(y, g(y))$\n\n**åˆ¶ç´„**\n\nè¾ºã®ã‚³ã‚¹ãƒˆã®æœ€å¤§ã‚’ $x$ ã¨ã—ã¦\n\n- $s \\neq t$\n- $0 \\leq s, t \\lt n$\n- `min_cost_slope`ã‚„`min_cost_max_flow`ã‚’åˆã‚ã›ã¦è¤‡æ•°å›å‘¼ã‚“ã ã¨ãã®æŒ™å‹•ã¯æœªå®šç¾©\n- `s`ã‹ã‚‰`t`ã¸æµã—ãŸãƒ•ãƒ­ãƒ¼ã®æµé‡ãŒ `Cap` ã«åã¾ã‚‹ã€‚\n- æµã—ãŸãƒ•ãƒ­ãƒ¼ã®ã‚³ã‚¹ãƒˆã®ç·å’ŒãŒ `Cost` ã«åã¾ã‚‹ã€‚\n- (Cost : `int`): $0 \\leq nx \\leq 2 \\times 10^9 + 1000$\n- (Cost : `ll`): $0 \\leq nx \\leq 8 \\times 10^{18} + 1000$\n\n**è¨ˆç®—é‡**\n\n$F$ ã‚’æµé‡ã€$m$ ã‚’è¿½åŠ ã—ãŸè¾ºã®æœ¬æ•°ã¨ã—ã¦\n\n- $O(F (n + m) \\log (n + m))$\n\n## edges\n\n```cpp\nstruct edge<Cap, Cost> {\n    int from, to;\n    Cap cap, flow;\n    Cost cost;\n};\n\n(1) mcf_graph<Cap, Cost>::edge graph.get_edge(int i);\n(2) vector<mcf_graph<Cap, Cost>::edge> graph.edges();\n```\n\n- ä»Šã®å†…éƒ¨ã®è¾ºã®çŠ¶æ…‹ã‚’è¿”ã™\n- è¾ºã®é †ç•ªã¯add_edgeã§è¿½åŠ ã•ã‚ŒãŸé †ç•ªã¨åŒä¸€\n\n$m$ ã‚’è¿½åŠ ã•ã‚ŒãŸè¾ºæ•°ã¨ã—ã¦\n\n**åˆ¶ç´„**\n\n- (1): $0 \\leq i \\lt m$\n\n**è¨ˆç®—é‡**\n\n- (1): $O(1)$\n- (2): $O(m)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/mincostflow>\n#include <iostream>\n\nusing namespace std;\nusing namespace atcoder;\n\nconst long long BIG = 1'000'000'000;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    /**\n     * generate (s -> row -> column -> t) graph\n     * i-th row correspond to vertex i\n     * i-th col correspond to vertex n + i\n     **/\n    mcf_graph<int, long long> g(2 * n + 2);\n    int s = 2 * n, t = 2 * n + 1;\n\n    // we can \"waste\" the flow\n    g.add_edge(s, t, n * k, BIG);\n\n    for (int i = 0; i < n; i++) {\n        g.add_edge(s, i, k, 0);\n        g.add_edge(n + i, t, k, 0);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            long long a;\n            cin >> a;\n            g.add_edge(i, n + j, 1, BIG - a);\n        }\n    }\n\n    auto result = g.flow(s, t, n * k);\n    cout << 1LL * n * k * BIG - result.second << endl;\n\n    vector<string> grid(n, string(n, '.'));\n    auto edges = g.edges();\n    for (auto e : edges) {\n        if (e.from == s || e.to == t || e.flow == 0) continue;\n\n        grid[e.from][e.to - n] = 'X';\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << grid[i] << endl;\n    }\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/modint.hpp\n```cpp hash\n#ifndef ATCODER_MODINT_HPP\n#define ATCODER_MODINT_HPP 1\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n#include \"atcoder/internal_math\"\n#include \"atcoder/internal_type_traits\"\n\nnamespace atcoder {\n\nnamespace internal {\n\nstruct modint_base {};\nstruct static_modint_base : modint_base {};\n\ntemplate <class T> using is_modint = std::is_base_of<modint_base, T>;\ntemplate <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n\n}  // namespace internal\n\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\nstruct static_modint : internal::static_modint_base {\n    using mint = static_modint;\n\n  public:\n    static constexpr int mod() { return m; }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    static_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    static_modint(T v) {\n        long long x = (long long)(v % (long long)(umod()));\n        if (x < 0) x += umod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    static_modint(T v) {\n        _v = (unsigned int)(v % umod());\n    }\n\n    int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v -= rhs._v;\n        if (_v >= umod()) _v += umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        unsigned long long z = _v;\n        z *= rhs._v;\n        _v = (unsigned int)(z % umod());\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        if (prime) {\n            assert(_v);\n            return pow(umod() - 2);\n        } else {\n            auto eg = internal::inv_gcd(_v, m);\n            assert(eg.first == 1);\n            return eg.second;\n        }\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static constexpr unsigned int umod() { return m; }\n    static constexpr bool prime = internal::is_prime<m>;\n};\n\ntemplate <int id> struct dynamic_modint : internal::modint_base {\n    using mint = dynamic_modint;\n\n  public:\n    static int mod() { return (int)(bt.umod()); }\n    static void set_mod(int m) {\n        assert(1 <= m);\n        bt = internal::barrett(m);\n    }\n    static mint raw(int v) {\n        mint x;\n        x._v = v;\n        return x;\n    }\n\n    dynamic_modint() : _v(0) {}\n    template <class T, internal::is_signed_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        long long x = (long long)(v % (long long)(mod()));\n        if (x < 0) x += mod();\n        _v = (unsigned int)(x);\n    }\n    template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n    dynamic_modint(T v) {\n        _v = (unsigned int)(v % mod());\n    }\n\n    int val() const { return _v; }\n\n    mint& operator++() {\n        _v++;\n        if (_v == umod()) _v = 0;\n        return *this;\n    }\n    mint& operator--() {\n        if (_v == 0) _v = umod();\n        _v--;\n        return *this;\n    }\n    mint operator++(int) {\n        mint result = *this;\n        ++*this;\n        return result;\n    }\n    mint operator--(int) {\n        mint result = *this;\n        --*this;\n        return result;\n    }\n\n    mint& operator+=(const mint& rhs) {\n        _v += rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator-=(const mint& rhs) {\n        _v += mod() - rhs._v;\n        if (_v >= umod()) _v -= umod();\n        return *this;\n    }\n    mint& operator*=(const mint& rhs) {\n        _v = bt.mul(_v, rhs._v);\n        return *this;\n    }\n    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n\n    mint operator+() const { return *this; }\n    mint operator-() const { return mint() - *this; }\n\n    mint pow(long long n) const {\n        assert(0 <= n);\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    mint inv() const {\n        auto eg = internal::inv_gcd(_v, mod());\n        assert(eg.first == 1);\n        return eg.second;\n    }\n\n    friend mint operator+(const mint& lhs, const mint& rhs) {\n        return mint(lhs) += rhs;\n    }\n    friend mint operator-(const mint& lhs, const mint& rhs) {\n        return mint(lhs) -= rhs;\n    }\n    friend mint operator*(const mint& lhs, const mint& rhs) {\n        return mint(lhs) *= rhs;\n    }\n    friend mint operator/(const mint& lhs, const mint& rhs) {\n        return mint(lhs) /= rhs;\n    }\n    friend bool operator==(const mint& lhs, const mint& rhs) {\n        return lhs._v == rhs._v;\n    }\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\n        return lhs._v != rhs._v;\n    }\n\n  private:\n    unsigned int _v;\n    static internal::barrett bt;\n    static unsigned int umod() { return bt.umod(); }\n};\ntemplate <int id> internal::barrett dynamic_modint<id>::bt(998244353);\n\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\nusing modint = dynamic_modint<-1>;\n\nnamespace internal {\n\ntemplate <class T>\nusing is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n\ntemplate <class T>\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n\ntemplate <class> struct is_dynamic_modint : public std::false_type {};\ntemplate <int id>\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n\ntemplate <class T>\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n\n}  // namespace internal\n\n}  // namespace atcoder\n\n#endif  // ATCODER_MODINT_HPP\n\n```\n\n# ! Documentation\n# Modint\n\nè‡ªå‹•ã§modã‚’å–ã‚‹æ§‹é€ ä½“ã§ã™ã€‚AC Libraryã¯modintã‚’ä½¿ã‚ãªãã¨ã‚‚å…¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒä½¿ãˆã‚‹ã‚ˆã†ã«æ•´å‚™ã—ã¦ã„ã‚‹ã®ã§ã€å¿…ãšã—ã‚‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’æŠŠæ¡ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“\bã€‚\n\nå¤šãã®å•é¡Œã§ã¯ `modint998244353`, `modint1000000007`, `modint` ã®ã©ã‚Œã‹ã‚’ä½¿ãˆã°ååˆ†ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ãˆã¾ã™ã€‚\n\n```cpp\n#include <atcoder/modint>\n#include <iostream>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = modint998244353;\n// or: typedef modint998244353 mint;\n\nint main() {\n    // print sum of array (mod 998244353)\n    int n;\n    cin >> n;\n    mint sum = 0;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        sum += x;\n    }\n    cout << sum.val() << endl;\n}\n```\n\nmodãŒfixedã§ãªã„å ´åˆã¯ã€`modint` ã‚’ä½¿ç”¨ã—ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ã€‚\n\n```cpp\n#include <atcoder/modint>\n#include <iostream>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = modint;\n// or: typedef modint mint;\n\nint main() {\n    // print sum of array (input mod)\n    int n, mod;\n    cin >> n >> mod;\n    mint::set_mod(mod);\n    mint sum = 0;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        sum += x;\n    }\n    cout << sum.val() << endl;\n}\n```\n\nä»¥ä¸‹ã®é–¢æ•°ã‚‰ã¯ã€`set_mod` ã‚’é™¤ã $3$ ã¤ã¨ã‚‚ã«å¯¾ã—ã¦å‹•ãã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\n(1) modint x()\n(2) modint x<T>(T y)\n```\n\n- (1) modintã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚$0$ ãŒæ ¼ç´ã•ã‚Œã¾ã™ã€‚\n- (2) æ•´æ•°å‹ `T`(`int, char, ull, bool, ...`) ã«å¯¾ã™ã‚‹ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ã™ã€‚`y` ã®modã‚’å–ã£ã¦modintã«æ ¼ç´ã—ã¾ã™ã€‚\n\n## set_mod\n\n```cpp\nvoid modint::set_mod(int m)\n```\n\nmodã‚’è¨­å®šã—ã¾ã™ã€‚æœ€åˆã«å‘¼ã‚“ã§ãã ã•ã„ã€‚\n\n**åˆ¶ç´„**\n\n- $1 \\leq m \\leq 2 \\times 10^9 + 1000$\n\n**è¨ˆç®—é‡**\n\n- $O(1)$\n\n## mod\n\n```cpp\nint modint::mod()\n```\n\nmodã‚’è¿”ã—ã¾ã™ã€‚\n\n## val\n\n```cpp\nint x.val();\n```\n\n`x`ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å€¤ã‚’è¿”ã—ã¾ã™ã€‚\n\n## å„ç¨®æ¼”ç®—\n\n```cpp\n-modint;\n\nmodint++;\nmodint--;\n++modint;\n--modint;\n\nmodint + modint;\nmodint - modint;\nmodint * modint;\nmodint / modint;\n\nmodint += modint;\nmodint -= modint;\nmodint *= modint;\nmodint /= modint;\n\nmodint == modint;\nmodint != modint;\n```\n\nãŒå‹•ãã¾ã™ã€‚\n\n```cpp\nmodint x = 10;\n1 + x;\n```\n\nã‚‚(`modint(1) + x`ã¨è‡ªå‹•ã§è§£é‡ˆã•ã‚Œã‚‹ã®ã§)å‹•ãã¾ã™ã€‚\n\n```cpp\nmodint::set_mod(11);\nmodint y = 10;\nint z = 1234;\ny * z;\n```\n\nã‚‚`y * modint(z)`ã¨è§£é‡ˆã•ã‚Œã€å‹•ãã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `a / b`(or `a /= b`)ã‚’è¡Œãªã†æ™‚ã€`gcd(b.val(), mod) == 1`\n\n**è¨ˆç®—é‡**\n\n- $O(1)$ (å‰²ã‚Šç®—ä»¥å¤–)\n- $O(\\log \\mathrm{mod})$ (å‰²ã‚Šç®—)\n\n## pow\n\n```cpp\nmodint x.pow(ll n)\n```\n\n$x^n$ ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\le n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## inv\n\n```cpp\nmodint x.inv()\n```\n\n$xy \\equiv 1$ ãªã‚‹ $y$ ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `gcd(x.val(), mod) = 1`\n\n**è¨ˆç®—é‡**\n\n- $O(\\log \\mathrm{mod})$\n\n## raw\n\n```cpp\nmodint modint::raw(int x)\n```\n\n`x`ã«å¯¾ã—ã¦modã‚’å–ã‚‰ãšã«ã€`modint(x)`ã‚’è¿”ã™ã€‚\n\nå®šæ•°å€é«˜é€ŸåŒ–ã®ãŸã‚ã®é–¢æ•°ã§ã™ã€‚\n\nä¸Šã§è¿°ã¹ãŸã‚ˆã†ã«\n\n```cpp\nmodint a;\nint i;\na += i;\n```\n\nã¯ã€`i`ãŒmodä»¥ä¸Šã§ã‚‚å‹•ãã¾ã™ã€‚å‹æ‰‹ã«`i`ã«å¯¾ã—ã¦modã‚’å–ã‚‹ãŸã‚ã§ã™ã€‚\n\nã§ã™ãŒã€ãŸã¨ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã§ã¯ã€`i`ãŒmodã‚’è¶…ãˆãªã„ã“ã¨ã‚’ä¿è¨¼ã§ãã¾ã™ã€‚\n\n```cpp\nint main() {\n    modint::set_mod(1000000007);\n    modint a = 1;\n    for (int i = 1; i < 100000; i++) {\n        a += i;\n    }\n}\n```\n\nã“ã®ã‚ˆã†ãªæ™‚ã«ã€\n\n```cpp\nint main() {\n    modint::set_mod(1000000007);\n    modint a = 1;\n    for (int i = 1; i < 100000; i++) {\n        a += modint::raw(i);\n    }\n}\n```\n\nã¨æ›¸ãã¨ã€modã®å›æ•°ã‚’æ¸›ã‚‰ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚\n\nå½“ç„¶ãªãŒã‚‰`modint::raw(x)`ã«modä»¥ä¸Šã®å€¤ã‚’å…¥ã‚ŒãŸã¨ãã®æŒ™å‹•ã¯æœªå®šç¾©ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq x \\lt \\mathrm{mod}$\n\n## Tips(other mod)\n\nå•é¡Œæ–‡ã§ä»–ã®mod (ä¾‹: `1000000009`) ãŒä¸ãˆã‚‰ã‚Œã‚‹å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™\n\n```cpp\nusing mint = static_modint<1000000009>;\n```\n\n`modint998244353`, `modint1000000007` ã¯ã€`static_modint<998244353>`, `static_modint<1000000007>`ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ãªã£ã¦ã„ã¾ã™ã€‚\n\n```cpp\nusing modint998244353 = static_modint<998244353>;\nusing modint1000000007 = static_modint<1000000007>;\n```\n\n## Tips(è¤‡æ•°mod)\n\nè¤‡æ•°ç¨®é¡modã‚’ä½¿ç”¨ã—ãŸã„å ´åˆä»¥ä¸‹ã®ã‚ˆã†ã«ã§ãã¾ã™\n\n```cpp\nusing mint0 = dynamic_modint<0>;\nusing mint1 = dynamic_modint<1>;\n```\n\n`modint`ã¯ã€`dynamic_modint<-1>`ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ãªã£ã¦ã„ã¾ã™ã€‚\n\n```cpp\nusing modint = dynamic_modint<-1>;\n```\n\n## ä¾‹\n\n```cpp\n#include <atcoder/modint>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nusing mint = static_modint<11>;\nint main() {\n    mint a = 10;\n    mint b(3);\n\n    // equal\n    assert(a == 21);\n    assert(a == -1);\n    assert(-1 == a);\n\n    // negative\n    assert(-b == 8);\n\n    // plus\n    assert(a + b == 2);  // (10 + 3) mod 11\n    assert(1 + a == 0);\n\n    // minus\n    assert(a - b == 7);  // (10 - 3) mod 11\n    assert(b - a == 4);\n\n    // mul\n    assert(a * b == 8);  // (10 * 3) mod 11\n\n    // inv\n    assert(b.inv() == 4);  // (3 * 4) mod 11 == 1\n\n    // div\n    assert(a / b == 7);  // (10 * 4) mod 11\n\n    // +=, -=, *=, /=\n    a += b;\n    assert(a == 2 && b == 3);\n    a -= b;\n    assert(a == 10 && b == 3);\n    a *= b;\n    assert(a == 8 && b == 3);\n    a /= b;\n    assert(a == 10 && b == 3);\n\n    // pow\n    assert(mint(2).pow(4) == 5);  // 16 mod 11\n\n    // print value\n    printf(\"%d\\n\", a.val());  // 10\n\n    // get mod\n    assert(mint::mod() == 11 && a.mod() == 11);\n\n    // mint(x) ã¨æ›¸ãã¨modã‚’å–ã‚‹æ“ä½œãŒç™ºç”Ÿã—ã¾ã™((x % mod + mod) % modã‚’modintã«ä»£å…¥ã—ã¾ã™)\n    // mint::raw(x) ã¯xã‚’modã‚’å–ã‚‰ãšã«ä»£å…¥ã™ã‚‹ã®ã§é«˜é€Ÿã§ã™(ã‚‚ã¡ã‚ã‚“xãŒ[0, mod)ã§ã‚ã‚‹ã“ã¨ã‚’åˆ©ç”¨è€…ãŒä¿è¨¼ã—ãªã„ã¨ã„ã‘ã¾ã›ã‚“)\n    assert(mint::raw(3) == 3);\n}\n\n```\n\n\n",
  "# ! atcoder/scc.hpp\n```cpp hash\n#ifndef ATCODER_SCC_HPP\n#define ATCODER_SCC_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\n#include \"atcoder/internal_scc\"\n\nnamespace atcoder {\n\nstruct scc_graph {\n  public:\n    scc_graph() : internal(0) {}\n    explicit scc_graph(int n) : internal(n) {}\n\n    void add_edge(int from, int to) {\n        int n = internal.num_vertices();\n        assert(0 <= from && from < n);\n        assert(0 <= to && to < n);\n        internal.add_edge(from, to);\n    }\n\n    std::vector<std::vector<int>> scc() { return internal.scc(); }\n\n  private:\n    internal::scc_graph internal;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_SCC_HPP\n\n```\n\n# ! Documentation\n# SCC\n\næœ‰å‘ã‚°ãƒ©ãƒ•ã‚’å¼·é€£çµæˆåˆ†åˆ†è§£ã—ã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\nscc_graph graph(int n)\n```\n\n$n$ é ‚ç‚¹ $0$ è¾ºã®æœ‰å‘ã‚°ãƒ©ãƒ•ã‚’ä½œã‚‹ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## add_edge\n\n```cpp\nvoid graph.add_edge(int from, int to)\n```\n\né ‚ç‚¹ `from` ã‹ã‚‰é ‚ç‚¹ `to` ã¸æœ‰å‘è¾ºã‚’è¶³ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq \\mathrm{from} \\lt n$\n- $0 \\leq \\mathrm{to} \\lt n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(1)$\n\n## scc\n\n```cpp\nvector<vector<int>> graph.scc()\n```\n\nä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªã€ã€Œé ‚ç‚¹ã®ãƒªã‚¹ãƒˆã€ã®ãƒªã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚\n\n- å…¨ã¦ã®é ‚ç‚¹ãŒã¡ã‚‡ã†ã©1ã¤ãšã¤ã€ã©ã‚Œã‹ã®ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¾ã™ã€‚\n- å†…å´ã®ãƒªã‚¹ãƒˆã¨å¼·é€£çµæˆåˆ†ãŒä¸€å¯¾ä¸€ã«å¯¾å¿œã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆå†…ã§ã®é ‚ç‚¹ã®é †åºã¯æœªå®šç¾©ã§ã™ã€‚\n- ãƒªã‚¹ãƒˆã¯ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚ç•°ãªã‚‹å¼·é€£çµæˆåˆ†ã®é ‚ç‚¹ $u, v$ ã«ã¤ã„ã¦ã€$u$ ã‹ã‚‰ $v$ ã«åˆ°é”ã§ãã‚‹æ™‚ã€$u$ ã®å±ã™ã‚‹ãƒªã‚¹ãƒˆã¯ $v$ ã®å±ã™ã‚‹ãƒªã‚¹ãƒˆã‚ˆã‚Šã‚‚å‰ã§ã™ã€‚\n\n**è¨ˆç®—é‡**\n\nè¿½åŠ ã—ãŸè¾ºã®æœ¬æ•°ã‚’ $m$ ã¨ã—ã¦\n\n- $O(n + m)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/scc>\n#include <cstdio>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    scc_graph g(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g.add_edge(u, v);\n    }\n\n    auto scc = g.scc();\n\n    printf(\"%d\\n\", int(scc.size()));\n    for (auto v : scc) {\n        printf(\"%d\", int(v.size()));\n        for (int x : v) {\n            printf(\" %d\", x);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/segtree.hpp\n```cpp hash\n#ifndef ATCODER_SEGTREE_HPP\n#define ATCODER_SEGTREE_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <functional>\n#include <vector>\n\n#include \"atcoder/internal_bit\"\n\nnamespace atcoder {\n\n#if __cplusplus >= 201703L\n\ntemplate <class S, auto op, auto e> struct segtree {\n    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\n                  \"op must work as S(S, S)\");\n    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\n                  \"e must work as S()\");\n\n#else\n\ntemplate <class S, S (*op)(S, S), S (*e)()> struct segtree {\n\n#endif\n\n  public:\n    segtree() : segtree(0) {}\n    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}\n    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {\n        size = (int)internal::bit_ceil((unsigned int)(_n));\n        log = internal::countr_zero((unsigned int)size);\n        d = std::vector<S>(2 * size, e());\n        for (int i = 0; i < _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i >= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 <= p && p < _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i <= log; i++) update(p >> i);\n    }\n\n    S get(int p) const {\n        assert(0 <= p && p < _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) const {\n        assert(0 <= l && l <= r && r <= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l < r) {\n            if (l & 1) sml = op(sml, d[l++]);\n            if (r & 1) smr = op(d[--r], smr);\n            l >>= 1;\n            r >>= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() const { return d[1]; }\n\n    template <bool (*f)(S)> int max_right(int l) const {\n        return max_right(l, [](S x) { return f(x); });\n    }\n    template <class F> int max_right(int l, F f) const {\n        assert(0 <= l && l <= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l >>= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l < size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l & -l) != l);\n        return _n;\n    }\n\n    template <bool (*f)(S)> int min_left(int r) const {\n        return min_left(r, [](S x) { return f(x); });\n    }\n    template <class F> int min_left(int r, F f) const {\n        assert(0 <= r && r <= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!f(op(d[r], sm))) {\n                while (r < size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r & -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector<S> d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_SEGTREE_HPP\n\n```\n\n# ! Documentation\n# Segtree\n\n[ãƒ¢ãƒã‚¤ãƒ‰](https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89) $(S, \\cdot: S \\times S \\to S, e \\in S)$ã€ã¤ã¾ã‚Š\n\n- çµåˆå¾‹: $(a \\cdot b) \\cdot c$ = $a \\cdot (b \\cdot c)$ for all $a, b, c \\in S$\n- å˜ä½å…ƒã®å­˜åœ¨: $a \\cdot e$ = $e \\cdot a$ = $a$ for all $a \\in S$\n\nã‚’æº€ãŸã™ä»£æ•°æ§‹é€ ã«å¯¾ã—ä½¿ç”¨ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚\n\né•·ã• $n$ ã® $S$ ã®é…åˆ—ã«å¯¾ã—ã€\n\n- è¦ç´ ã® $1$ ç‚¹å¤‰æ›´\n- åŒºé–“ã®è¦ç´ ã®ç·ç©ã®å–å¾—\n\nã‚’ $O(\\log n)$ ã§è¡Œã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚è©³ç´°ãªè¦ä»¶ã¯ [Appendix](./appendix.html) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\nã¾ãŸã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ªãƒ©ã‚¯ãƒ«ã¨ã—ã¦`op, e`ã®2ç¨®é¡ã‚’ä½¿ç”¨ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ãŒå®šæ•°æ™‚é–“ã§å‹•ãã‚‚ã®ã¨ä»®å®šã—ãŸã¨ãã®è¨ˆç®—é‡ã‚’è¨˜è¿°ã—ã¾ã™ã€‚ã‚ªãƒ©ã‚¯ãƒ«å†…éƒ¨ã®è¨ˆç®—é‡ãŒ $O(f(n))$ ã§ã‚ã‚‹å ´åˆã¯ã™ã¹ã¦ã®è¨ˆç®—é‡ãŒ $O(f(n))$ å€ã¨ãªã‚Šã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\n(1) segtree<S, op, e> seg(int n)\n(2) segtree<S, op, e> seg(vector<S> v)\n```\n\n- å‹ `S`\n- äºŒé …æ¼”ç®— `S op(S a, S b)`\n- å˜ä½å…ƒ `S e()`\n\nã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ã¨ã—ã¦ã€Range Min Queryãªã‚‰ã°\n\n```cpp\nint op(int a, int b) {\n    return min(a, b);\n}\n\nint e() {\n    return (int)(1e9);\n}\n\nsegtree<int, op, e> seg(10);\n```\n\nã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚\n\n- (1): é•·ã• `n` ã®æ•°åˆ— `a` ã‚’ä½œã‚Šã¾ã™ã€‚åˆæœŸå€¤ã¯å…¨éƒ¨`e()`ã§ã™ã€‚\n- (2): é•·ã• `n = v.size()` ã®æ•°åˆ— `a` ã‚’ä½œã‚Šã¾ã™ã€‚`v` ã®å†…å®¹ãŒåˆæœŸå€¤ã¨ãªã‚Šã¾ã™ã€‚\n\nè©³ã—ãã¯ã€ä½¿ç”¨ä¾‹ã‚„ [ã“ã¡ã‚‰](https://atcoder.jp/contests/practice2/editorial) ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## set\n\n```cpp\nvoid seg.set(int p, S x)\n```\n\n`a[p]` ã« `x` ã‚’ä»£å…¥ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq p < n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## get\n\n```cpp\nS seg.get(int p)\n```\n\n`a[p]` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq p < n$\n\n**è¨ˆç®—é‡**\n\n- $O(1)$\n\n## prod\n\n```cpp\nS seg.prod(int l, int r)\n```\n\n`op(a[l], ..., a[r - 1])` ã‚’ã€ãƒ¢ãƒã‚¤ãƒ‰ã®æ€§è³ªã‚’æº€ãŸã—ã¦ã„ã‚‹ã¨ä»®å®šã—ã¦è¨ˆç®—ã—ã¾ã™ã€‚$l = r$ ã®ã¨ãã¯ `e()` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq l \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## all_prod\n\n```cpp\nS seg.all_prod()\n```\n\n`op(a[0], ..., a[n - 1])` ã‚’è¨ˆç®—ã—ã¾ã™ã€‚$n = 0$ ã®ã¨ãã¯ `e()` ã‚’è¿”ã—ã¾ã™ã€‚\n\n**è¨ˆç®—é‡**\n\n- $O(1)$\n\n## max_right\n\n```cpp\n(1) int seg.max_right<f>(int l)\n(2ğŸ’») int seg.max_right<F>(int l, F f)\n```\n\n- (1): é–¢æ•° `bool f(S x)` ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  \n- (2): `S`ã‚’å¼•æ•°ã«ã¨ã‚Š`bool`ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  \n\nä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ `r` ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚\n\n- `r = l` ã‚‚ã—ãã¯ `f(op(a[l], a[l + 1], ..., a[r - 1])) = true`\n- `r = n` ã‚‚ã—ãã¯ `f(op(a[l], a[l + 1], ..., a[r])) = false`\n\n`f`ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€`f(op(a[l], a[l + 1], ..., a[r - 1])) = true` ã¨ãªã‚‹æœ€å¤§ã® `r`ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `f`ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)\n- `f(e()) = true`\n- $0 \\leq l \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## min_left\n\n```cpp\n(1) int seg.min_left<f>(int r)\n(2ğŸ’») int seg.min_left<F>(int r, F f)\n```\n\n- (1): é–¢æ•° `bool f(S x)` ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  \n- (2): `S`ã‚’å¼•æ•°ã«ã¨ã‚Š`bool`ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  \n\nä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ `l` ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚\n\n- `l = r` ã‚‚ã—ãã¯ `f(op(a[l], a[l + 1], ..., a[r - 1])) = true`\n- `l = 0` ã‚‚ã—ãã¯ `f(op(a[l - 1], a[l], ..., a[r - 1])) = false`\n\n`f`ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€`f(op(a[l], a[l + 1], ..., a[r - 1])) = true` ã¨ãªã‚‹æœ€å°ã® `l`ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚\n\n**åˆ¶ç´„**\n\n- `f`ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)\n- `f(e()) = true`\n- $0 \\leq r \\leq n$\n\n**è¨ˆç®—é‡**\n\n- $O(\\log n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/segtree>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint op(int a, int b) { return max(a, b); }\n\nint e() { return -1; }\n\nint target;\n\nbool f(int v) { return v < target; }\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &(a[i]));\n    }\n\n    segtree<int, op, e> seg(a);\n\n    for (int i = 0; i < q; i++) {\n        int t;\n        scanf(\"%d\", &t);\n        if (t == 1) {\n            int x, v;\n            scanf(\"%d %d\", &x, &v);\n            x--;\n            seg.set(x, v);\n        } else if (t == 2) {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            l--;\n            printf(\"%d\\n\", seg.prod(l, r));\n        } else if (t == 3) {\n            int p;\n            scanf(\"%d %d\", &p, &target);\n            p--;\n            printf(\"%d\\n\", seg.max_right<f>(p) + 1);\n        }\n    }\n}\n\n```\n\n\n",
  "# ! atcoder/string.hpp\n```cpp hash\n#ifndef ATCODER_STRING_HPP\n#define ATCODER_STRING_HPP 1\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n\nnamespace internal {\n\nstd::vector<int> sa_naive(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n        if (l == r) return false;\n        while (l < n && r < n) {\n            if (s[l] != s[r]) return s[l] < s[r];\n            l++;\n            r++;\n        }\n        return l == n;\n    });\n    return sa;\n}\n\nstd::vector<int> sa_doubling(const std::vector<int>& s) {\n    int n = int(s.size());\n    std::vector<int> sa(n), rnk = s, tmp(n);\n    std::iota(sa.begin(), sa.end(), 0);\n    for (int k = 1; k < n; k *= 2) {\n        auto cmp = [&](int x, int y) {\n            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n            int rx = x + k < n ? rnk[x + k] : -1;\n            int ry = y + k < n ? rnk[y + k] : -1;\n            return rx < ry;\n        };\n        std::sort(sa.begin(), sa.end(), cmp);\n        tmp[sa[0]] = 0;\n        for (int i = 1; i < n; i++) {\n            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        std::swap(tmp, rnk);\n    }\n    return sa;\n}\n\n// SA-IS, linear-time suffix array construction\n// Reference:\n// G. Nong, S. Zhang, and W. H. Chan,\n// Two Efficient Algorithms for Linear Time Suffix Array Construction\ntemplate <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\nstd::vector<int> sa_is(const std::vector<int>& s, int upper) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    if (n == 1) return {0};\n    if (n == 2) {\n        if (s[0] < s[1]) {\n            return {0, 1};\n        } else {\n            return {1, 0};\n        }\n    }\n    if (n < THRESHOLD_NAIVE) {\n        return sa_naive(s);\n    }\n    if (n < THRESHOLD_DOUBLING) {\n        return sa_doubling(s);\n    }\n\n    std::vector<int> sa(n);\n    std::vector<bool> ls(n);\n    for (int i = n - 2; i >= 0; i--) {\n        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n    }\n    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n    for (int i = 0; i < n; i++) {\n        if (!ls[i]) {\n            sum_s[s[i]]++;\n        } else {\n            sum_l[s[i] + 1]++;\n        }\n    }\n    for (int i = 0; i <= upper; i++) {\n        sum_s[i] += sum_l[i];\n        if (i < upper) sum_l[i + 1] += sum_s[i];\n    }\n\n    auto induce = [&](const std::vector<int>& lms) {\n        std::fill(sa.begin(), sa.end(), -1);\n        std::vector<int> buf(upper + 1);\n        std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n        for (auto d : lms) {\n            if (d == n) continue;\n            sa[buf[s[d]]++] = d;\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        sa[buf[s[n - 1]]++] = n - 1;\n        for (int i = 0; i < n; i++) {\n            int v = sa[i];\n            if (v >= 1 && !ls[v - 1]) {\n                sa[buf[s[v - 1]]++] = v - 1;\n            }\n        }\n        std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n        for (int i = n - 1; i >= 0; i--) {\n            int v = sa[i];\n            if (v >= 1 && ls[v - 1]) {\n                sa[--buf[s[v - 1] + 1]] = v - 1;\n            }\n        }\n    };\n\n    std::vector<int> lms_map(n + 1, -1);\n    int m = 0;\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms_map[i] = m++;\n        }\n    }\n    std::vector<int> lms;\n    lms.reserve(m);\n    for (int i = 1; i < n; i++) {\n        if (!ls[i - 1] && ls[i]) {\n            lms.push_back(i);\n        }\n    }\n\n    induce(lms);\n\n    if (m) {\n        std::vector<int> sorted_lms;\n        sorted_lms.reserve(m);\n        for (int v : sa) {\n            if (lms_map[v] != -1) sorted_lms.push_back(v);\n        }\n        std::vector<int> rec_s(m);\n        int rec_upper = 0;\n        rec_s[lms_map[sorted_lms[0]]] = 0;\n        for (int i = 1; i < m; i++) {\n            int l = sorted_lms[i - 1], r = sorted_lms[i];\n            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n            bool same = true;\n            if (end_l - l != end_r - r) {\n                same = false;\n            } else {\n                while (l < end_l) {\n                    if (s[l] != s[r]) {\n                        break;\n                    }\n                    l++;\n                    r++;\n                }\n                if (l == n || s[l] != s[r]) same = false;\n            }\n            if (!same) rec_upper++;\n            rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n        }\n\n        auto rec_sa =\n            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n\n        for (int i = 0; i < m; i++) {\n            sorted_lms[i] = lms[rec_sa[i]];\n        }\n        induce(sorted_lms);\n    }\n    return sa;\n}\n\n}  // namespace internal\n\nstd::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n    assert(0 <= upper);\n    for (int d : s) {\n        assert(0 <= d && d <= upper);\n    }\n    auto sa = internal::sa_is(s, upper);\n    return sa;\n}\n\ntemplate <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n    int n = int(s.size());\n    std::vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n    std::vector<int> s2(n);\n    int now = 0;\n    for (int i = 0; i < n; i++) {\n        if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n        s2[idx[i]] = now;\n    }\n    return internal::sa_is(s2, now);\n}\n\nstd::vector<int> suffix_array(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return internal::sa_is(s2, 255);\n}\n\n// Reference:\n// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,\n// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its\n// Applications\ntemplate <class T>\nstd::vector<int> lcp_array(const std::vector<T>& s,\n                           const std::vector<int>& sa) {\n    assert(s.size() == sa.size());\n    int n = int(s.size());\n    assert(n >= 1);\n    std::vector<int> rnk(n);\n    for (int i = 0; i < n; i++) {\n        assert(0 <= sa[i] && sa[i] < n);\n        rnk[sa[i]] = i;\n    }\n    std::vector<int> lcp(n - 1);\n    int h = 0;\n    for (int i = 0; i < n; i++) {\n        if (h > 0) h--;\n        if (rnk[i] == 0) continue;\n        int j = sa[rnk[i] - 1];\n        for (; j + h < n && i + h < n; h++) {\n            if (s[j + h] != s[i + h]) break;\n        }\n        lcp[rnk[i] - 1] = h;\n    }\n    return lcp;\n}\n\nstd::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return lcp_array(s2, sa);\n}\n\n// Reference:\n// D. Gusfield,\n// Algorithms on Strings, Trees, and Sequences: Computer Science and\n// Computational Biology\ntemplate <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n    int n = int(s.size());\n    if (n == 0) return {};\n    std::vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int& k = z[i];\n        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector<int> z_algorithm(const std::string& s) {\n    int n = int(s.size());\n    std::vector<int> s2(n);\n    for (int i = 0; i < n; i++) {\n        s2[i] = s[i];\n    }\n    return z_algorithm(s2);\n}\n\n}  // namespace atcoder\n\n#endif  // ATCODER_STRING_HPP\n\n```\n\n# ! Documentation\n# String\n\næ–‡å­—åˆ—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è©°ã‚åˆã‚ã›ã§ã™ã€‚\næ–‡å­—åˆ—ã«é–¢ã™ã‚‹æ§˜ã€…ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚\n\næ–‡å­—åˆ— `s` ã® $a$ ç•ªç›®ã‹ã‚‰ $b - 1$ ç•ªç›®ã®è¦ç´ ã®substringã‚’ã€`s[a..b)`ã¨è¡¨è¨˜ã—ã¾ã™ã€‚\n\n## suffix_array\n\n```cpp\n(1) vector<int> suffix_array(string s)\n(2) vector<int> suffix_array<T>(vector<T> s)\n(3) vector<int> suffix_array(vector<int> s, int upper)\n```\n\né•·ã• $n$ ã®æ–‡å­—åˆ— `s` ã®Suffix Arrayã¨ã—ã¦ã€é•·ã• $n$ ã® vector ã‚’è¿”ã™ã€‚\nSuffix Array `sa` ã¯ $(0, 1, \\dots, n - 1)$ ã®é †åˆ—ã§ã‚ã£ã¦ã€å„ $i = 0,1, \\cdots ,n-2$ ã«ã¤ã„ã¦ `s[sa[i]..n) < s[sa[i+1]..n)` ã‚’æº€ãŸã™ã‚‚ã®ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n- (2) `T` ã¯ `int, uint, ll, ull`\n- (3) $0 \\leq \\mathrm{upper} \\leq 10^8$\n- (3) $s$ ã®ã™ã¹ã¦ã®è¦ç´  $x$ ã«ã¤ã„ã¦ $0 \\leq x \\leq \\mathrm{upper}$\n\nè¨ˆç®—é‡\n\n- (1) $O(n)$\n- (2) æ™‚é–“ $O(n \\log n)$ ç©ºé–“ $O(n)$\n- (3) $O(n + \\mathrm{upper})$\n\n## lcp_array\n\n```cpp\n(1) vector<int> lcp_array(string s, vector<int> sa)\n(2) vector<int> lcp_array<T>(vector<T> s, vector<int> sa)\n```\n\né•·ã• $n$ ã®æ–‡å­—åˆ— `s` ã®LCP Arrayã¨ã—ã¦ã€é•·ã• $n-1$ ã®é…åˆ—ã‚’è¿”ã™ã€‚$i$ ç•ªç›®ã®è¦ç´ ã¯ `s[sa[i]..n), s[sa[i+1]..n)` ã® LCP(Longest Common Prefix) ã®é•·ã•ã€‚\n\n**åˆ¶ç´„**\n\n- `sa` ã¯ `s` ã®Suffix Array\n- $1 \\leq n \\leq 10^8$\n- (2): `T` ã¯ `int, uint, ll, ull`\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## z_algorithm\n\n```cpp\n(1) vector<int> z_algorithm(string s)\n(2) vector<int> z_algorithm<T>(vector<T> s)\n```\n\nå…¥åŠ›ã®é•·ã•ã‚’ $n$ ã¨ã—ã¦ã€é•·ã• $n$ ã®é…åˆ—ã‚’è¿”ã™ã€‚\n$i$ ç•ªç›®ã®è¦ç´ ã¯ `s[0..n)`ã¨`s[i..n)`ã®LCP(Longest Common Prefix)ã®é•·ã•ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n- (2): `T` ã¯ `int, uint, ll, ull`\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/string>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    string s = \"missisippi\";\n\n    vector<int> sa = suffix_array(s);\n\n    vector<string> answer = {\n        \"i\",\n        \"ippi\",\n        \"isippi\",\n        \"issisippi\",\n        \"missisippi\",\n        \"pi\",\n        \"ppi\",\n        \"sippi\",\n        \"sisippi\",\n        \"ssisippi\",\n    };\n\n    assert(sa.size() == answer.size());\n    for (int i = 0; i < int(sa.size()); i++) {\n        assert(s.substr(sa[i]) == answer[i]);\n    }\n}\n\n```\n\n\n```cpp\n#include <atcoder/string>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    static char buf[500'001];\n    scanf(\"%s\", buf);\n    string s = buf;\n    vector<int> sa = suffix_array(s);\n    long long answer = 1LL * s.size() * (s.size() + 1) / 2;\n    for (auto x : lcp_array(s, sa)) {\n        answer -= x;\n    }\n    printf(\"%lld\\n\", answer);\n    return 0;\n}\n\n```\n\n\n",
  "# ! atcoder/twosat.hpp\n```cpp hash\n#ifndef ATCODER_TWOSAT_HPP\n#define ATCODER_TWOSAT_HPP 1\n\n#include <cassert>\n#include <vector>\n\n#include \"atcoder/internal_scc\"\n\nnamespace atcoder {\n\n// Reference:\n// B. Aspvall, M. Plass, and R. Tarjan,\n// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean\n// Formulas\nstruct two_sat {\n  public:\n    two_sat() : _n(0), scc(0) {}\n    explicit two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n\n    void add_clause(int i, bool f, int j, bool g) {\n        assert(0 <= i && i < _n);\n        assert(0 <= j && j < _n);\n        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n    }\n    bool satisfiable() {\n        auto id = scc.scc_ids().second;\n        for (int i = 0; i < _n; i++) {\n            if (id[2 * i] == id[2 * i + 1]) return false;\n            _answer[i] = id[2 * i] < id[2 * i + 1];\n        }\n        return true;\n    }\n    std::vector<bool> answer() { return _answer; }\n\n  private:\n    int _n;\n    std::vector<bool> _answer;\n    internal::scc_graph scc;\n};\n\n}  // namespace atcoder\n\n#endif  // ATCODER_TWOSAT_HPP\n\n```\n\n# ! Documentation\n# 2-SAT\n\n2-SATã‚’è§£ãã¾ã™ã€‚\nå¤‰æ•° $x_0, x_1, \\cdots, x_{N - 1}$ ã«é–¢ã—ã¦ã€\n\n- $(x_i = f) \\lor (x_j = g)$\n\nã¨ã„ã†ã‚¯ãƒ­ãƒ¼ã‚ºã‚’è¶³ã—ã€ã“ã‚Œã‚’ã™ã¹ã¦æº€ãŸã™å¤‰æ•°ã®å‰²å½“ãŒã‚ã‚‹ã‹ã‚’è§£ãã¾ã™ã€‚\n\n## ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\n```cpp\ntwo_sat ts(int n)\n```\n\n$n$ å¤‰æ•°ã®2-SATã‚’ä½œã‚Šã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq n \\leq 10^8$\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## add_clause\n\n```cpp\nvoid ts.add_clause(int i, bool f, int j, bool g)\n```\n\n$(x_i = f) \\lor (x_j = g)$ ã¨ã„ã†ã‚¯ãƒ­ãƒ¼ã‚ºã‚’è¶³ã—ã¾ã™ã€‚\n\n**åˆ¶ç´„**\n\n- $0 \\leq i \\lt n$\n- $0 \\leq j \\lt n$\n\n**è¨ˆç®—é‡**\n\n- ãªã‚‰ã— $O(1)$\n\n## satisfiable\n\n```cpp\nbool ts.satisfiable()\n```\n\næ¡ä»¶ã‚’è¶³ã™å‰²å½“ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã€‚å‰²å½“ãŒå­˜åœ¨ã™ã‚‹ãªã‚‰ã°`true`ã€ãã†ã§ãªã„ãªã‚‰`false`ã‚’è¿”ã™ã€‚\n\n**åˆ¶ç´„**\n\n- è¤‡æ•°å›å‘¼ã¶ã“ã¨ã‚‚å¯èƒ½ã€‚\n\n**è¨ˆç®—é‡**\n\nè¶³ã—ãŸåˆ¶ç´„ã®å€‹æ•°ã‚’ $m$ ã¨ã—ã¦\n\n- $O(n + m)$\n\n## answer\n\n```cpp\nvector<bool> ts.answer()\n```\n\næœ€å¾Œã«å‘¼ã‚“ã  `satisfiable` ã®ã€ã‚¯ãƒ­ãƒ¼ã‚ºã‚’æº€ãŸã™å‰²å½“ã‚’è¿”ã™ã€‚`satisfiable` ã‚’å‘¼ã¶å‰ã‚„ã€`satisfiable` ã§å‰²å½“ãŒå­˜åœ¨ã—ãªã‹ã£ãŸã¨ãã«ã“ã®é–¢æ•°ã‚’å‘¼ã¶ã¨ã€ä¸­èº«ãŒæœªå®šç¾©ã®é•·ã• $n$ ã® vectorã‚’è¿”ã™ã€‚\n\n**è¨ˆç®—é‡**\n\n- $O(n)$\n\n## ä¾‹\n\n```cpp\n#include <atcoder/twosat>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing namespace atcoder;\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    // ts[i] = (i-th flag is located on x[i])\n    two_sat ts(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (abs(x[i] - x[j]) < d) {\n                // cannot use both of x[i] and x[j]\n                ts.add_clause(i, false, j, false);\n            }\n            if (abs(x[i] - y[j]) < d) {\n                ts.add_clause(i, false, j, true);\n            }\n            if (abs(y[i] - x[j]) < d) {\n                ts.add_clause(i, true, j, false);\n            }\n            if (abs(y[i] - y[j]) < d) {\n                ts.add_clause(i, true, j, true);\n            }\n        }\n    }\n\n    if (!ts.satisfiable()) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    cout << \"Yes\" << endl;\n    auto answer = ts.answer();\n    for (int i = 0; i < n; i++) {\n        if (answer[i])\n            cout << x[i] << endl;\n        else\n            cout << y[i] << endl;\n    }\n\n    return 0;\n}\n\n```\n\n\n",
  "# ! ac-library/appendix\n\n# Appendix / FAQ\n\n## å‹•ä½œç’°å¢ƒ\n\n- `ATCODER_`ã§å§‹ã¾ã‚‹åå‰ã®ãƒã‚¯ãƒ­ã‚’ä½¿ã‚ãªã„ã§ãã ã•ã„ã€‚\n- å¤šãã®ç’°å¢ƒã§å‹•ãã‚ˆã†ã«ä½œã£ã¦ã„ã¾ã™ãŒã€C++æ¨™æº–ã‹ã‚‰ã‚ã‚‹ç¨‹åº¦ã®æ‹¡å¼µæ©Ÿèƒ½ã‚’è¦æ±‚ã—ã¾ã™ã€‚å…·ä½“çš„ã«ã¯ä»¥ä¸‹ã®ã“ã¨ã‚’ä»®å®šã—ã¾ã™ã€‚\n  - `__int128 / unsigned __int128(g++, clang++)` ã‹ `_mul128 / _umul128(Visual Studio)` ãŒä½¿ãˆã‚‹ã“ã¨\n  - `__builtin_(ctz/ctzll/clz/clzll/popcount)(g++, clang++)` ã‹ `_BitScan(Forward/Reverse)(Visual Studio)` ãŒä½¿ãˆã‚‹ã“ã¨\n  - `char / short / int / ll`ãŒ `8 / 16 / 32 / 64` bitã€ã¾ãŸãã®`unsigned`å‹(ãŠã‚ˆã³`signed char`)ã‚‚åŒã˜bité•·\n  - ğŸ’» [ç¬¦å·ä»˜ãæ•´æ•°å‹ãŒ2ã®è£œæ•°è¡¨ç¾ã§ã‚ã‚‹ã“ã¨ã‚’è¦å®š](https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html)\n\n## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\n### g++ / clang++ã¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\nä¸€ç•ªã‚ã‹ã‚Šã‚„ã™ã„æ–¹æ³•ã¯ã€ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«æ›¸ã„ãŸã‚ˆã†ã«ã€`main.cpp`ã¨åŒã˜å ´æ‰€ã«`atcoder`ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç½®ã„ã¦ã€`g++ main.cpp -std=c++14 -I .`ã¨å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã“ã§ã€`.`ã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¡¨ã™è¨˜å·ã§ã™(æœ¬å½“ã« I ã®å¾Œã«ã‚¹ãƒšãƒ¼ã‚¹ã€ç‚¹ã€ã¨å…¥åŠ›ã—ã¾ã™ã€‚)\n\n`atcoder`ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã„ã¡ã„ã¡ã‚³ãƒ”ãƒ¼ã—ãŸããªã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚\n\n- `g++ main.cpp -std=c++14 -I /path/to/ac-library`ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹ (`/path/to/ac-library` ã¯è‡ªåˆ†ã®PCã® `ac-library` ã‚’ç½®ã„ã¦ã‚ã‚‹å ´æ‰€ã¸æ›¸ãæ›ãˆã¦ãã ã•ã„)ã€‚\n- ç’°å¢ƒå¤‰æ•° `CPLUS_INCLUDE_PATH` ã§ã€`CPLUS_INCLUDE_PATH=\"/path/to/ac-library\"`ã®ã‚ˆã†ã«`atcoder`ãƒ•ã‚©ãƒ«ãƒ€ã®å ´æ‰€ã‚’æŒ‡å®šã™ã‚‹ã€‚(Windowsã®å ´åˆã¯ã€[ãƒ¦ãƒ¼ã‚¶ãƒ¼ç’°å¢ƒå¤‰æ•°ã®è¨­å®šç”»é¢](https://img.atcoder.jp/practice2/01333b7c5575b09b5868376ef242aa52.png) ã§ã€å¤‰æ•°ã®æ¬„ã« `CPLUS_INCLUDE_PATH` å€¤ã®æ¬„ã« `C:\\path\\to\\ac-library`ã€€ãªã©ã¨å…¥åŠ›ã™ã‚‹ã€‚ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã¯ãªããƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ç”¨ã„ã‚‹ã“ã¨ã«æ³¨æ„ã€‚ãªãŠã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã¯ç’°å¢ƒã«ã‚ˆã£ã¦ã¯å††è¨˜å·ã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™)ã€‚ã™ã‚‹ã¨æ™®é€šã«`g++ main.cpp -std=c++14`ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã‚‹ã€‚\n\n### Visual Studioã¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\nå¤ã„Visual Studioã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã€ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚Visual Studio 2019 / 2022ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚\n\nVisual StudioãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ã‚©ãƒ«ãƒ€ãŒã‚ã‚‹ã¯ãšã§ã™ã€‚\n\n- `C:\\Program Files\\Microsoft Visual Studio\\2022\\(Community, Professional or Enterprise)\\VC\\Tools\\MSVC\\(Some number, e.g. 14.35.32215)\\include`\n- `C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\(Community, Professional or Enterprise)\\VC\\Tools\\MSVC\\(Some number, e.g. 14.27.29110)\\include`\n\nã“ã®ãªã‹ã«ä¸¸ã”ã¨ `atcoder` ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚ã¤ã¾ã‚Šã€\n\n- `C:\\Program Files\\Microsoft Visual Studio\\2022\\(Community, Professional or Enterprise)\\VC\\Tools\\MSVC\\(Some number, e.g. 14.35.32215)\\include\\atcoder\\dsu.hpp`\n\nã¨ãªã‚‹ã‚ˆã†ã«é…ç½®ã—ã¦ãã ã•ã„ã€‚\n\n## ä»–ã®ã‚¸ãƒ£ãƒƒã‚¸ã¸ã®æå‡ºæ–¹æ³•\n\n`expander.py`ã¨ã„ã†ã‚¹ã‚¯ãƒªãƒ—ãƒˆ(python3.5 or later)ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚\n`python3 expander.py main.cpp`ã¨å®Ÿè¡Œã™ã‚‹ã¨`combined.cpp`ãŒç”Ÿæˆã•ã‚Œã€ã“ã‚Œã¯ä»–ã®ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚¸ãƒ£ãƒƒã‚¸ã«æå‡ºã§ãã‚‹å½¢ã«ãªã£ã¦ã„ã¾ã™ã€‚\n\nãƒ†ã‚¹ãƒˆã¯ã—ã¦ã„ã¾ã™ãŒã€ã‚µãƒãƒ¼ãƒˆä¿è¨¼å¤–ã§ã™ã€‚\n\n## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®è¡¨è¨˜æ³• / æ˜è¨˜ã•ã‚Œã¦ã„ãªã„ã“ã¨\n\n### ğŸ’»ãƒãƒ¼ã‚¯\n\nC++åˆå¿ƒè€…ã«ã¯é›£ã—ã„ã‹ã‚‚ã—ã‚Œãªã„æ©Ÿèƒ½ã‚’è¡¨ã™ãƒãƒ¼ã‚¯ã§ã™ã€‚AC Libraryã¯ã€ã“ã®ãƒãƒ¼ã‚¯ã®ä»˜ã„ãŸç®‡æ‰€ã‚’ç„¡è¦–ã—ã¦ã‚‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ çš„ã«å›°ã‚‰ãªã„ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚modintãªã©ãŒè©²å½“ã—ã¾ã™ã€‚\n\n### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé–¢æ•°\n\nä¾‹ãˆã°`suffix_array(v)`ã¯`vector<int>`, `vector<ll>`ãªã©ã‚’å¼•æ•°ã«å–ã‚Œã‚‹ã®ã§ã™ãŒã€ã“ã‚Œã‚‰ã‚’ã¾ã¨ã‚ã¦`suffix_array<T>(vector<T> v)`ã¨è¡¨è¨˜ã—ã¾ã™ã€‚\n\nä¾‹ãˆã°`vector<int>`ã«æ ¼ç´ã•ã‚ŒãŸæ•´æ•°åˆ— $v$ ã® suffix array ã‚’æ±‚ã‚ãŸã„ã¨ãã€\n\n```cpp\nvector<int> sa = suffix_array(v);\n// vector<int> sa = suffix_array<int>(v); ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„\n```\n\nã¨ä½¿ã„ã¾ã™ã€‚\n\n### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿\n\næ§‹é€ ä½“ã€ä¾‹ãˆã°`scc_graph` ãªã©ã¯ã€ã‚µãƒ³ãƒ—ãƒ«ã®ã‚ˆã†ã«\n\n```cpp\n#include <atcoder/scc>;\nusing namespace atcoder;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scc_graph g(n); // n é ‚ç‚¹ã‹ã‚‰ãªã‚‹ã‚°ãƒ©ãƒ•ã‚’ç”Ÿæˆ\n    return 0;\n}\n```\n\nã¨ã„ã£ãŸå®£è¨€æ–¹æ³•ã ã‘ã§ãªãã€æ¬¡ã®ã‚ˆã†ã«åˆæœŸåŒ–ãªã—ã§å®£è¨€ã™ã‚‹ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚\n\n```cpp\n#include <atcoder/scc>;\nusing namespace atcoder;\n\nscc_graph g;\n\nint main() {\n    return 0;\n}\n```\n\nã“ã®ã‚ˆã†ã«å®£è¨€ã—ãŸã¨ãã®æŒ™å‹•ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼‰ã¯ã€\n\n- $O(1)$\n- ç”Ÿæˆã•ã‚ŒãŸã‚‚ã®ã¸ã®ãƒ¡ãƒ³ãƒå¤‰æ•°ã®ã‚¢ã‚¯ã‚»ã‚¹, ãƒ¡ãƒ³ãƒé–¢æ•°ã®å‘¼ã³å‡ºã—ã®æŒ™å‹•ã¯å…¨ã¦æœªå®šç¾©\n\nã¨ãªã‚Šã¾ã™ã€‚ã¾ãŸã€æ§‹é€ ä½“ã«å¾Œã‹ã‚‰ä»£å…¥ã™ã‚‹ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ã€‚\n\n```cpp\n#include <atcoder/scc>;\nusing namespace atcoder;\n\nscc_graph g;\n\nint main() {\n    g = scc_graph(10);\n    return 0;\n}\n```\n\n### è¾ºã®å‹\n\næœ€å¤§æµãƒ©ã‚¤ãƒ–ãƒ©ãƒªãªã©ã§ã¯ã€è¾ºã®å‹ã¨ã—ã¦ `mf_graph<Cap>::edge` ã¨ã„ã†ã®ã‚’ä½¿ã„ã¾ã™ã€‚\n\nä¾‹ãˆã°ã€`mf_graph<int>` ã®è¾ºã®å‹ã¯ `mf_graph<int>::edge` ã§ã™ã€‚\n`::` ãŒè¦‹æ…£ã‚Œãªã„ã‹ã‚‚ã—ã‚Œãªã„ã§ã™ãŒã€`mf_graph<int>::edge` ã¨ã„ã†æ–‡å­—åˆ—ã‚’`int`ã‚„`string`ã®ã‚ˆã†ã«æ‰±ãˆã°ã‚ˆã„ã§ã™ã€‚ä¾‹ãˆã°\n\n```cpp\nvector<mf_graph<int>::edge> v;\nmf_graph<int>::edge e;\n```\n\nã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚\n\n### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°\n\nconvolution ã®ã‚ˆã†ã«ã€ä»¥ä¸‹ã®ã‚ˆã†ãªè¡¨è¨˜æ³•ã‚’ç”¨ã„ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚\n\n```cpp\nvector<T> convolution<int m = 998244353>(vector<T> a, vector<T> b)\n```\n\nã“ã‚Œã¯ã€äºŒé€šã‚Šã®ä½¿ã„æ–¹ãŒã§ãã‚‹ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚\n\n```cpp\nvector<long long> c = convolution(a, b);\nvector<long long> c = convolution<924844033>(a, b);\n```\n\nä¸Šæ®µã®ã‚ˆã†ã«ä½¿ã£ãŸå ´åˆã¯ã€$m$ ã®å€¤ã¯è‡ªå‹•çš„ã« $998244353$ ã¨ãªã‚Šã¾ã™ã€‚\nä¸‹æ®µã®ã‚ˆã†ã«ä½¿ã£ãŸå ´åˆã¯ã€$m$ ã®å€¤ã¯æ˜ç¤ºçš„ã«ä¸ãˆãŸå€¤ (ã“ã®å ´åˆã¯ $924844033$) ã¨ãªã‚Šã¾ã™ã€‚\n\n### ğŸ’» explicit æŒ‡å®šå­\n\n`modint` ä»¥å¤–ã®æ§‹é€ ä½“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã¯ explicit ãŒä»˜ã„ã¦ã„ã¾ã™ã€‚\n\n## Segtree / LazySegtree ã®å³å¯†ãªè¦ä»¶\n\nSegtree / LazySegtree ã‚’ä½¿ã„ãŸã„çŠ¶æ³ã«ãŠã„ã¦ã€æ‰±ã†ä»£æ•°æ§‹é€ ãŒç„¡é™é›†åˆã§ã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ä¸ãˆã‚‰ã‚ŒãŸåŒºé–“ã® $\\mathrm{max}$ ã‚’æ±‚ã‚ã‚‹ã€ä¸ãˆã‚‰ã‚ŒãŸåŒºé–“å†…ã®å…¨ã¦ã®è¦ç´ ã«å®šæ•°ã‚’è¶³ã™ã€ã®äºŒç¨®é¡ã®ã‚¯ã‚¨ãƒªã«å¯¾å¿œã™ã‚‹ LazySegtree ã¯ã‚ˆãã‚ã‚Šã¾ã™ãŒã€ã“ã®ã¨ããŸã¨ãˆã° $S = \\mathrm{int}$ ã¨ã—ã¦ã—ã¾ã†ã¨ã€$S$ ã¯åŠ æ³•ã«ã¤ã„ã¦é–‰ã˜ã¦ã„ãªã„ (overflow ã‚’èµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚‹) ãŸã‚ã€å³å¯†ãªæ„å‘³ã§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæœ¬ç·¨ã®åˆ¶ç´„ã‚’æº€ãŸã—ã¾ã›ã‚“ã€‚ãã“ã§ã€AC Library ã§ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå ´åˆæ­£ã—ãå‹•ãã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™ã€‚\n\n### Segtree\n\n- $S$ ã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæœ¬ç·¨ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªä»£æ•°æ§‹é€ ã§ã‚ã‚‹ã€‚\n- $e \\in S' \\subseteq S$\n- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¸ãˆã‚‹å‹ã‚„æ¼”ç®—ã¯ã€å¼•æ•°ãŠã‚ˆã³æ¼”ç®—çµæœãŒå…¨ã¦ $S'$ ã«å«ã¾ã‚Œã‚‹å ´åˆã€æ­£ã—ãå‹•ã\n- ä»»æ„ã®æ™‚ç‚¹ã®ã€ä»»æ„ã®é€£ç¶šãªéƒ¨åˆ†åˆ— $a_l, a_{l+1}, \\cdots, a_{r-1}$ ã«ã¤ã„ã¦ã€ç©$a_l \\cdot a_{l+1} \\cdot \\ldots \\cdot a_{r-1}$ ãŒ $S'$ ã«å«ã¾ã‚Œã‚‹ã€‚\n\n### LazySegtree\n\n- $(S, F)$ ã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæœ¬ç·¨ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªä»£æ•°æ§‹é€ ã§ã‚ã‚‹ã€‚\n- $e \\in S' \\subseteq S, \\mathrm{id} \\in F' \\subseteq F$\n- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¸ãˆã‚‹å‹ã‚„æ¼”ç®—ã¯ã€å¼•æ•°ãŠã‚ˆã³æ¼”ç®—çµæœãŒå…¨ã¦ $S', F'$ ã«å«ã¾ã‚Œã‚‹å ´åˆã€æ­£ã—ãå‹•ã\n- ä»»æ„ã®æ™‚ç‚¹ã®ã€ä»»æ„ã®é€£ç¶šãªéƒ¨åˆ†åˆ— $a_l, a_{l+1}, \\cdots, a_{r-1}$ ã«ã¤ã„ã¦ã€ç©$a_l \\cdot a_{l+1} \\cdot \\ldots \\cdot a_{r-1}$ ãŒ $S'$ ã«å«ã¾ã‚Œã‚‹ã€‚\n- ä»»æ„ã®è¦ç´ ã«å¯¾ã—ã€ãã®è¦ç´ ã«é©ç”¨ã•ã‚ŒãŸé–¢æ•°ã‚’é †ã« $f_0, f_1, ..., f_{k-1} \\in F$ ã¨ã—ãŸã¨ãã€ä»»æ„ã®é€£ç¶šãªéƒ¨åˆ†åˆ— $f_l, \\cdots, f_{r-1}$ ã«ã¤ã„ã¦ã€åˆæˆ $f_{r-1} \\circ f_{l+1} \\circ \\dots \\circ f_{l}$ ãŒ $F'$ ã«å«ã¾ã‚Œã‚‹ã€‚\n\nãŸã¨ãˆã°ã€æœ€åˆã®ä¾‹ã§è‡ªç„¶ã« $(S, F)$ ã‚’å®šã‚ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ãŒã€ã“ã‚Œã¯ç„¡é™é›†åˆã§ã™ã€‚\n\n- $S = \\mathbb{Z} \\cup \\{-\\infty\\}$\n- $S$ ä¸Šã®äºŒé …æ¼”ç®— $\\cdot$ ã¯ $\\mathrm{max}$ ($e = -\\infty$)\n- $F$ ã¯æ•´æ•°å®šæ•°ã‚’åŠ ãˆã‚‹å†™åƒå…¨ä½“ã®é›†åˆ ($\\mathrm{id}$ ã¯ $0$ ã‚’åŠ ãˆã‚‹å†™åƒ)\n\n$(S', F')$ ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šã‚ã‚‹ã“ã¨ã§ã€åˆ¶ç´„ãŒååˆ†å°ã•ã‘ã‚Œã°ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚\n\n- $S' = (\\mathbb{Z} \\cap (-2^{31}, 2^{31})) \\cup \\{-\\infty\\}$\n- $Sâ€™$ ã‚’è¡¨ã™å‹ã¨ã—ã¦ $\\mathrm{int}$ ã‚’é¸æŠã—ã€$-\\infty$ ã¯ $\\mathrm{int}$ ã®å…ƒ $-2^{31}$ ã¨ã—ã¦ã€ãã®ä»–ã¯ãã®ã¾ã¾è¡¨ã™\n- $F'$ ã¯åŒºé–“ $[-2^{31}, 2^{31})$ å†…ã®æ•´æ•°å®šæ•°ã‚’åŠ ãˆã‚‹å†™åƒå…¨ä½“ã®é›†åˆã§ã€å‹ $\\mathrm{int}$ ã‚’ç”¨ã„ã¦è‡ªç„¶ãªå¯¾å¿œã§è¡¨ã™\n\n## maxflowã®æŒ™å‹•\n\nå†…éƒ¨ã§ã¯å„è¾º $e$ ã«ã¤ã„ã¦ $2$ ã¤ã®å¤‰æ•°ã€æµé‡ $f_e$ ã¨å®¹é‡ $c_e$ ã‚’ç®¡ç†ã—ã¦ã„ã¾ã™ã€‚é ‚ç‚¹ $v$ ã‹ã‚‰å‡ºã‚‹è¾ºã®é›†åˆã‚’ $\\mathrm{out}(v)$, å…¥ã‚‹è¾ºã®é›†åˆã‚’$\\mathrm{in}(v)$ ã€ã¾ãŸé ‚ç‚¹ $v$ ã«ã¤ã„ã¦ $g(v, f) = \\sum_{e \\in \\mathrm{in}(v)}{f_e} - \\sum_{e \\in \\mathrm{out}(v)}{f_e}$ ã¨ã—ã¾ã™ã€‚\n\n### `flow(s, t)`\n\nã“ã‚Œã‚’å‘¼ã¶ã¨å„è¾ºã®æµé‡ã‚’å¤‰æ›´ã—ã¾ã™ã€‚å³å¯†ã«ã¯å¤‰æ›´å‰ã¨å¤‰æ›´å¾Œã®æµé‡ã‚’ $f_e$, $f'_e$ ã¨ã—ã¦ã€ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã™ã€‚\n\n- $0 \\leq f'_e \\leq c_e$\n- $s, t$ ä»¥å¤–ã®å…¨ã¦ã®é ‚ç‚¹ $v$ ã«ã¤ã„ã¦ã€$g(v, f) = g(v, f')$\n- (flow_limitã‚’æŒ‡å®šã—ãŸå ´åˆ) $g(t, f') - g(t, f) \\leq \\mathrm{flow\\\\_limit}$\n- $g(t, f') - g(t, f)$ ãŒä»¥ä¸Šã®æ¡ä»¶ã‚’æº€ãŸã™ã†ã¡æœ€å¤§ã€‚ã“ã® $g(t, f') - g(t, f)$ ã‚’è¿”ã™\n\n### `min_cut(s)`\n\nå„è¾º $e = (u, v, f_e, c_e)$ã«ã¤ã„ã¦ã€$f_e \\lt c_e$ ãªã‚‰ã°è¾º $(u, v)$ ã‚’å¼µã‚Šã€$0 \\lt f_e$ ãªã‚‰ã°è¾º $(v, u)$ ã‚’å¼µã£ãŸã¨ä»®å®šã—ãŸã¨ãã€é ‚ç‚¹ $s$ ã‹ã‚‰åˆ°é”å¯èƒ½ãªé ‚ç‚¹ã®é›†åˆã‚’è¿”ã—ã¾ã™ã€‚\n\n### `change_edge(i, new_cap, new_flow)`\n\nè¾º $i$ ã®æµé‡ã€å®¹é‡ã®ã¿ã‚’ `new_flow`, `new_cap` ã¸å¤‰æ›´ã—ã¾ã™ã€‚\n\n",
  "# ! nanacpp/array_sum.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename T> class ArraySum {\nprivate:\n  usize n;\n  std::vector<T> prefix_sum;\n\npublic:\n  explicit ArraySum(const std::vector<T> &data)\n      : n(data.size()), prefix_sum(n + 1, 0) {\n    for (usize i = 0; i < n; ++i) {\n      prefix_sum[i + 1] = prefix_sum[i] + data[i];\n    }\n  }\n\n  /// åŒºé–“ [l, r) ã®å’Œã‚’è¿”ã™\n  T sum(size_t l, size_t r) const { return prefix_sum[r] - prefix_sum[l]; }\n\n  /// åŒºé–“ [l, r] ã®å’Œã‚’è¿”ã™\n  T sum_closed(size_t l, size_t r) const {\n    return prefix_sum[r + 1] - prefix_sum[l];\n  }\n};\n\n```\n",
  "# ! nanacpp/bisect.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename F>\n/// Finds the first index `i` in the half-open range `[l, r)` such that\n/// `cond(i)` is true. If no such index exists, returns `r`.\ni64 bisect_first(i64 l, i64 r, F &&cond) {\n  i64 left = l - 1;\n  i64 right = r;\n  while (left + 1 < right) {\n    i64 mid = left + (right - left) / 2;\n    if (cond(mid)) {\n      right = mid;\n    } else {\n      left = mid;\n    }\n  }\n  return right;\n}\n\ntemplate <typename F>\n/// Finds the first index `i` in the closed range `[l, r]` such that\n/// `cond(i)` is true. If no such index exists, returns `r + 1`.\ni64 bisect_first_closed(i64 l, i64 r, F &&cond) {\n  i64 left = l;\n  i64 right = r + 1;\n  while (left < right) {\n    i64 mid = left + (right - left) / 2;\n    if (cond(mid)) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n\ntemplate <typename F>\n/// Finds the last index `i` in the half-open range `[l, r)` such that\n/// `cond(i)` is true. If no such index exists, returns `l - 1`.\ni64 bisect_last(i64 l, i64 r, F &&cond) {\n  i64 left = l - 1;\n  i64 right = r;\n  while (left + 1 < right) {\n    i64 mid = left + (right - left) / 2;\n    if (cond(mid)) {\n      left = mid;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n}\n\ntemplate <typename F>\n/// Finds the last index `i` in the closed range `[l, r]` such that\n/// `cond(i)` is true. If no such index exists, returns `l - 1`.\ni64 bisect_last_closed(i64 l, i64 r, F &&cond) {\n  i64 left = l - 1;\n  i64 right = r;\n  while (left < right) {\n    i64 mid = left + (right - left + 1) / 2;\n    if (cond(mid)) {\n      left = mid;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return left;\n}\n\n```\n",
  "# ! nanacpp/core.hpp\n```cpp hash\n#pragma once\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fn auto\n#define let auto\n\n#define each(x, a) for (auto &x : a)\n#define each1(x, a) for (auto &x : a)\n#define each2(x, y, a) for (auto &[x, y] : a)\n#define each3(x, y, z, a) for (auto &[x, y, z] : a)\n#define each4(w, x, y, z, a) for (auto &[w, x, y, z] : a)\n\n#define enumerate(x, i, a)                                                     \\\n  for (usize i = 0; i < (usize)a.size(); ++i)                                  \\\n    if (auto &x = a[i]; true)\n#define enumerate1(x, i, a)                                                    \\\n  for (usize i = 0; i < (usize)a.size(); ++i)                                  \\\n    if (auto &x = a[i]; true)\n#define enumerate2(x, y, i, a)                                                 \\\n  usize i = 0;                                                                 \\\n  for (auto it = a.begin(); it != a.end(); ++it, ++i)                          \\\n    if (auto &[x, y] = *it; true)\n#define enumerate3(x, y, z, i, a)                                              \\\n  usize i = 0;                                                                 \\\n  for (auto it = a.begin(); it != a.end(); ++it, ++i)                          \\\n    if (auto &[x, y, z] = *it; true)\n#define enumerate4(w, x, y, z, i, a)                                           \\\n  usize i = 0;                                                                 \\\n  for (auto it = a.begin(); it != a.end(); ++it, ++i)                          \\\n    if (auto &[w, x, y, z] = *it; true)\n\n#define rep(i, a) for (int i = 0; i < (a); ++i)\n#define range(i, l, r) for (int i = (l); i < (r); ++i)\n#define rangei(i, l, r) for (int i = (l); i <= (r); ++i)\n\n#define chmax(var, val) var = std::max(var, val)\n#define chmin(var, val) var = std::min(var, val)\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sz(x) ((int)(x).size())\n\nusing ll = long long;\nusing i8 = int8_t;\nusing i16 = int16_t;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing isize = std::make_signed<std::size_t>::type;\nusing u8 = uint8_t;\nusing u16 = uint16_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing usize = std::make_unsigned<std::size_t>::type;\n\n```\n",
  "# ! nanacpp/cumulative_sum_2d.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\n// 2 æ¬¡å…ƒç´¯ç©å’Œ\ntemplate <typename T> class CumulativeSum2D {\nprivate:\n  usize height;\n  usize width;\n  std::vector<std::vector<T>> prefix;\n\npublic:\n  explicit CumulativeSum2D(const std::vector<std::vector<T>> &grid)\n      : height(grid.size()), width(height ? grid[0].size() : 0),\n        prefix(height + 1, std::vector<T>(width + 1, 0)) {\n    for (usize y = 0; y < height; ++y) {\n      assert(grid[y].size() == width);\n      for (usize x = 0; x < width; ++x) {\n        prefix[y + 1][x + 1] =\n            grid[y][x] + prefix[y][x + 1] + prefix[y + 1][x] -\n            prefix[y][x];\n      }\n    }\n  }\n\n  usize rows() const { return height; }\n  usize cols() const { return width; }\n\n  // é•·æ–¹å½¢ [top, bottom) Ã— [left, right) ã®å’Œ\n  T sum(usize top, usize left, usize bottom, usize right) const {\n    assert(top <= bottom);\n    assert(left <= right);\n    assert(bottom <= height);\n    assert(right <= width);\n    return prefix[bottom][right] - prefix[top][right] -\n           prefix[bottom][left] + prefix[top][left];\n  }\n\n  // é•·æ–¹å½¢ [top, bottom] Ã— [left, right] ã®å’Œ\n  T sum_closed(usize top, usize left, usize bottom, usize right) const {\n    assert(bottom < height);\n    assert(right < width);\n    return sum(top, left, bottom + 1, right + 1);\n  }\n};\n\n```\n",
  "# ! nanacpp/debug.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  os << \"[\";\n  for (usize i = 0; i < v.size(); ++i) {\n    os << v[i];\n    if (i + 1 != v.size()) {\n      os << \", \";\n    }\n  }\n  os << \"]\";\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    os << *it;\n    auto next_it = it;\n    ++next_it;\n    if (next_it != v.end()) {\n      os << \" \";\n    }\n  }\n  os << \"}\";\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::unordered_set<T> &v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    os << *it;\n    auto next_it = it;\n    ++next_it;\n    if (next_it != v.end()) {\n      os << \" \";\n    }\n  }\n  os << \"}\";\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::map<T, U> &m) {\n  os << \"{\";\n  for (auto it = m.begin(); it != m.end(); ++it) {\n    os << it->first << \": \" << it->second;\n    auto next_it = it;\n    ++next_it;\n    if (next_it != m.end()) {\n      os << \", \";\n    }\n  }\n  os << \"}\";\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::unordered_map<T, U> &m) {\n  os << \"{\";\n  for (auto it = m.begin(); it != m.end(); ++it) {\n    os << it->first << \": \" << it->second;\n    auto next_it = it;\n    ++next_it;\n    if (next_it != m.end()) {\n      os << \", \";\n    }\n  }\n  os << \"}\";\n  return os;\n}\n\n#ifdef ONLINE_JUDGE\n#define dbg(x) x\n#define dbg2(x) x\n#define dbg3(x) x\n#else\n#define dbg(x)                                                                 \\\n  ([&]() {                                                                     \\\n    auto _dbg_x = (x);                                                         \\\n    std::cerr << \"[dbg L\" << __LINE__ << \"] \" << #x << \" = \";                  \\\n    std::cerr << _dbg_x << std::endl;                                          \\\n    return _dbg_x;                                                             \\\n  }())\n#define dbg2(x)                                                                \\\n  ([&]() {                                                                     \\\n    auto _dbg_x = (x);                                                         \\\n    std::cerr << \"[[dbg L\" << __LINE__ << \"]] \" << #x << \" = \";                \\\n    std::cerr << _dbg_x << std::endl;                                          \\\n    return _dbg_x;                                                             \\\n  }())\n#define dbg3(x)                                                                \\\n  ([&]() {                                                                     \\\n    auto _dbg_x = (x);                                                         \\\n    std::cerr << \"[[[dbg L\" << __LINE__ << \"]]] \" << #x << \" = \";              \\\n    std::cerr << _dbg_x << std::endl;                                          \\\n    return _dbg_x;                                                             \\\n  }())\n#endif\n\n```\n",
  "# ! nanacpp/imos.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\n// Imos æ³•ï¼ˆå·®åˆ†é…åˆ—ï¼‰ã‚’æ‰±ã†ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£\ntemplate <typename T> class Imos {\nprivate:\n  std::vector<T> diff;\n  std::vector<T> built_values;\n  bool ready;\n\npublic:\n  explicit Imos(usize n) : diff(n + 1, 0), built_values(n, 0), ready(false) {}\n\n  usize size() const { return built_values.size(); }\n\n  // åŒºé–“ [l, r) ã« value ã‚’åŠ ç®—ã™ã‚‹\n  void add(usize l, usize r, const T &value) {\n    assert(l <= r);\n    assert(l <= size());\n    assert(r <= size());\n    diff[l] += value;\n    diff[r] -= value;\n    ready = false;\n  }\n\n  // åŒºé–“ [l, r] ã« value ã‚’åŠ ç®—ã™ã‚‹\n  void add_closed(usize l, usize r, const T &value) {\n    assert(l <= r);\n    assert(r < size());\n    add(l, r + 1, value);\n  }\n\n  [[nodiscard]] const std::vector<T> &build() {\n    if (!ready) {\n      T run = 0;\n      for (usize i = 0; i < size(); ++i) {\n        run += diff[i];\n        built_values[i] = run;\n      }\n      ready = true;\n    }\n    return built_values;\n  }\n\n  [[nodiscard]] const std::vector<T> &values() const {\n    assert(ready);\n    return built_values;\n  }\n\n  [[nodiscard]] const T &operator[](usize idx) const {\n    assert(ready);\n    return built_values[idx];\n  }\n\n  std::vector<T> applied(std::vector<T> base) {\n    assert(base.size() == size());\n    const auto &delta = build();\n    for (usize i = 0; i < size(); ++i) {\n      base[i] += delta[i];\n    }\n    return base;\n  }\n};\n\n```\n",
  "# ! nanacpp/imos_2d.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\n// 2 æ¬¡å…ƒ Imos æ³•ï¼ˆå·®åˆ†é…åˆ—ï¼‰\ntemplate <typename T> class Imos2D {\nprivate:\n  usize height;\n  usize width;\n  std::vector<std::vector<T>> diff;\n  std::vector<std::vector<T>> built_values;\n  bool ready;\n\npublic:\n  Imos2D(usize h, usize w)\n      : height(h), width(w), diff(h + 1, std::vector<T>(w + 1, 0)),\n        built_values(h, std::vector<T>(w, 0)), ready(false) {}\n\n  usize rows() const { return height; }\n  usize cols() const { return width; }\n\n  // é•·æ–¹å½¢ [top, bottom) Ã— [left, right) ã« value ã‚’åŠ ç®—\n  void add(usize top, usize left, usize bottom, usize right, const T &value) {\n    assert(top <= bottom);\n    assert(left <= right);\n    assert(bottom <= height);\n    assert(right <= width);\n    diff[top][left] += value;\n    diff[bottom][left] -= value;\n    diff[top][right] -= value;\n    diff[bottom][right] += value;\n    ready = false;\n  }\n\n  // é•·æ–¹å½¢ [top, bottom] Ã— [left, right] ã« value ã‚’åŠ ç®—\n  void add_closed(usize top, usize left, usize bottom, usize right,\n                  const T &value) {\n    assert(bottom < height);\n    assert(right < width);\n    add(top, left, bottom + 1, right + 1, value);\n  }\n\n  [[nodiscard]] const std::vector<std::vector<T>> &build() {\n    if (!ready) {\n      std::vector<std::vector<T>> acc(height + 1,\n                                      std::vector<T>(width + 1, 0));\n      for (usize y = 0; y <= height; ++y) {\n        for (usize x = 0; x <= width; ++x) {\n          T val = diff[y][x];\n          if (y > 0) {\n            val += acc[y - 1][x];\n          }\n          if (x > 0) {\n            val += acc[y][x - 1];\n          }\n          if (y > 0 && x > 0) {\n            val -= acc[y - 1][x - 1];\n          }\n          acc[y][x] = val;\n          if (y < height && x < width) {\n            built_values[y][x] = val;\n          }\n        }\n      }\n      ready = true;\n    }\n    return built_values;\n  }\n\n  [[nodiscard]] const std::vector<std::vector<T>> &values() const {\n    assert(ready);\n    return built_values;\n  }\n\n  const std::vector<T> &operator[](usize row) const {\n    assert(ready);\n    return built_values[row];\n  }\n\n  std::vector<std::vector<T>> applied(\n      std::vector<std::vector<T>> base) {\n    assert(base.size() == height);\n    for (const auto &row : base) {\n      assert(row.size() == width);\n    }\n    const auto &delta = build();\n    for (usize y = 0; y < height; ++y) {\n      for (usize x = 0; x < width; ++x) {\n        base[y][x] += delta[y][x];\n      }\n    }\n    return base;\n  }\n};\n\n```\n",
  "# ! nanacpp/input.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\n#define input(type, var)                                                       \\\n  type var;                                                                    \\\n  cin >> var;\n#define input_vec(type, var, n)                                                \\\n  std::vector<type> var(n);                                                    \\\n  for (usize i = 0; i < (usize)(n); ++i) {                                     \\\n    cin >> var[i];                                                             \\\n  }\n#define input_array(type, var, n)                                              \\\n  std::array<type, n> var;                                                     \\\n  for (usize i = 0; i < (usize)(n); ++i) {                                     \\\n    cin >> var[i];                                                             \\\n  }\n#define input_pair(type1, type2, var)                                          \\\n  std::pair<type1, type2> var;                                                 \\\n  cin >> var.first >> var.second;\n#define input_hpair(type1, type2, var)                                         \\\n  hpair<type1, type2> var;                                                     \\\n  cin >> var.first >> var.second;\n#define input_vec_pair(type1, type2, var, n)                                   \\\n  std::vector<std::pair<type1, type2>> var(n);                                 \\\n  for (usize i = 0; i < (usize)(n); ++i) {                                     \\\n    cin >> var[i].first >> var[i].second;                                      \\\n  }\n#define input_vec_hpair(type1, type2, var, n)                                  \\\n  std::vector<hpair<type1, type2>> var(n);                                     \\\n  for (usize i = 0; i < (usize)(n); ++i) {                                     \\\n    cin >> var[i].first >> var[i].second;                                      \\\n  }\n\n```\n",
  "# ! nanacpp/pair.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename T, typename U> class hpair {\npublic:\n  T first;\n  U second;\n  hpair() = default;\n  hpair(const T &f, const U &s) : first(f), second(s) {}\n  bool operator==(const hpair<T, U> &other) const {\n    return first == other.first && second == other.second;\n  }\n};\n\nnamespace std {\ntemplate <typename T, typename U> struct hash<hpair<T, U>> {\n  size_t operator()(const hpair<T, U> &p) const {\n    return hash<T>()(p.first) ^ (hash<U>()(p.second) << 1);\n  }\n};\n} // namespace std\n\n```\n",
  "# ! nanacpp/prime.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\nclass PrimeSieve {\nprivate:\n  int limit;\n  std::vector<int> primes_vec;\n  std::vector<int> least_prime;\n\n  void build() {\n    if (limit >= 0)\n      least_prime[0] = 0;\n    if (limit >= 1)\n      least_prime[1] = 1;\n\n    for (int i = 2; i <= limit; ++i) {\n      if (least_prime[i] == 0) {\n        least_prime[i] = i;\n        primes_vec.push_back(i);\n      }\n      for (int p : primes_vec) {\n        if (p > least_prime[i])\n          break;\n        ll mul = 1LL * i * p;\n        if (mul > limit)\n          break;\n        least_prime[mul] = p;\n      }\n    }\n  }\n\npublic:\n  explicit PrimeSieve(int n)\n      : limit(n), primes_vec(), least_prime(n + 1, 0) {\n    assert(limit >= 0);\n    build();\n  }\n\n  PrimeSieve(const PrimeSieve &) = delete;\n  PrimeSieve &operator=(const PrimeSieve &) = delete;\n  PrimeSieve(PrimeSieve &&) = default;\n  PrimeSieve &operator=(PrimeSieve &&) = default;\n\n  int max_n() const { return limit; }\n\n  const std::vector<int> &primes() const { return primes_vec; }\n\n  bool is_prime(int n) const {\n    assert(0 <= n && n <= limit);\n    return n >= 2 && least_prime[n] == n;\n  }\n\n  int least_factor(int n) const {\n    assert(1 <= n && n <= limit);\n    return least_prime[n];\n  }\n\n  std::vector<std::pair<int, int>> factorize_bounded(int n) const {\n    assert(1 <= n && n <= limit);\n    std::vector<std::pair<int, int>> factors;\n    while (n > 1) {\n      int p = least_prime[n];\n      int cnt = 0;\n      while (n % p == 0) {\n        n /= p;\n        ++cnt;\n      }\n      factors.push_back({p, cnt});\n    }\n    return factors;\n  }\n\n  /// n ã¯ limit^2 ä»¥ä¸‹ã§ã‚ã‚‹ã“ã¨ï¼ˆsqrt(n) ã¾ã§ã®ç´ æ•°ã‚’æŒã£ã¦ã„ã‚‹å‰æï¼‰\n  std::vector<std::pair<ll, int>> factorize(ll n) const {\n    assert(n >= 1);\n    assert(1LL * limit * limit >= n);\n    std::vector<std::pair<ll, int>> factors;\n    ll cur = n;\n    for (int p : primes_vec) {\n      if (1LL * p * p > cur)\n        break;\n      if (cur % p != 0)\n        continue;\n      int cnt = 0;\n      while (cur % p == 0) {\n        cur /= p;\n        ++cnt;\n      }\n      factors.push_back({p, cnt});\n    }\n    if (cur > 1) {\n      factors.push_back({cur, 1});\n    }\n    return factors;\n  }\n};\n\n```\n",
  "# ! nanacpp/sum.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename T, typename V> T sum(const V &vec) {\n  T total = 0;\n  each(x, vec) { total += x; }\n  return total;\n}\n\n```\n",
  "# ! nanacpp/tally.hpp\n```cpp hash\n#pragma once\n\n#include \"features/core.hpp\"\n\ntemplate <typename T> std::map<T, u64> tally(const std::vector<T> &data) {\n  std::map<T, u64> counts;\n  for (const auto &item : data) {\n    counts[item]++;\n  }\n  return counts;\n}\n\n\n```\n",
  "# ! Numbers Reference\n\n## Magic Number!\n\n- 998244353\n- 1000000007\n\n## Factorials\n\n| n    | n!          |\n| ---- | ----------- |\n| $0$  | $1$         |\n| $1$  | $1$         |\n| $2$  | $2$         |\n| $3$  | $6$         |\n| $4$  | $24$        |\n| $5$  | $120$       |\n| $6$  | $720$       |\n| $7$  | $5040$      |\n| $8$  | $40320$     |\n| $9$  | $362880$    |\n| $10$ | $3628800$   |\n| $11$ | $39916800$  |\n| $12$ | $479001600$ |\n\n## Number of Primes\n\n| n      | Number of Primes â‰¤ n |\n| ------ | -------------------- |\n| $10^1$ | $4$                  |\n| $10^2$ | $25$                 |\n| $10^3$ | $168$                |\n| $10^4$ | $1229$               |\n| $10^5$ | $9592$               |\n| $10^6$ | $78498$              |\n| $10^7$ | $664579$             |\n| $10^8$ | $5761455$            |\n| $10^9$ | $50847534$           |\n",
  "# ! scripts/test.py\n```py hash\n#!/usr/bin/env python3\nimport sys\nimport subprocess\nimport glob\n\nsource = sys.argv[1]\ncompile = subprocess.run([\"compileg++\", source])\nif compile.returncode != 0:\n    print(\"CE\")\n    sys.exit(1)\n\nnum_passed = 0\nnum_failed = 0\nfor test in glob.glob(\"test/*.in\"):\n    output = test[:-3] + \"out\"\n    result = subprocess.run(\n        [\"runcpp\"], input=open(test, \"rb\").read(), stdout=subprocess.PIPE\n    )\n    expected = open(output, \"rb\").read()\n    if result.stdout == expected:\n        print(f\"{test}: AC\")\n        num_passed += 1\n    else:\n        print(f\"{test}: WA\")\n        print(\"Expected:\")\n        print(expected.decode())\n        print(\"Got:\")\n        print(result.stdout.decode())\n        num_failed += 1\n\nprint(f\"Passed: {num_passed}, Failed: {num_failed}\")\nif num_failed > 0:\n    sys.exit(1)\n\n```\n",
  "# ! scripts/verify.py\n```py hash\n#!/usr/bin/env python3\nimport sys\nimport hashlib\n\nwith open(sys.argv[1], 'r') as f:\n    for line in f:\n        line = line.rstrip('\\n')\n        line_hash = hashlib.sha256(line.encode()).hexdigest()\n        print(f\"{line_hash[:4]} | {line}\")\n\n```\n"
]